# 1. はじめに
---
Neural Processing Unit (NPU) はHWニューラルネットワークアクセラレータであり、AI-GのNPUは、物体検出、画像分類、顔検出などのビジョンアプリケーション向けのニューラルネットワークの推論に最適化されています。NPUデバイスドライバは、ユーザー空間のニューラルネットワークアプリケーションがAI-G NPUを使用して組み込みLinux環境でニューラルネットワーク推論を行えるように、NPUを制御するインターフェースを提供します。
 
このドキュメントでは、AI-G SDKに含まれるNPUデバイスドライバとNPU APIの使用方法について説明します。
<br/><br/><br/><br/>
 
 
# 2. NPU Linuxデバイスドライバ
---
NPUデバイスドライバは以下を制御します。
 
- NPU HWの初期化
- コンパイルされたニューラルネットワークのNPU HWへの配信
- NPU HWの実行
- NPU HW処理 (推論) 結果の読み取り
 
NPUデバイスドライバで使用されるバッファ (コード、重み、ワーク、入力、および出力) には、連続した物理メモリ空間が必要です。このため、メモリ上のバッファは、Continuous Memory Allocator (CMA) を使用して内部的に割り当てられます。
NPUデバイスドライバは、コンパイルされたニューラルネットワークのコマンドファイルと重み/バイアスファイルを入力として受け取り、ネットワークファイル記述子 (fd) を生成します。また、ニューラルネットワークの入力と結果が格納されるバッファを割り当て、各バッファにアクセスするためのバッファfdを生成します。
 
推論を実行するには、
1. 入力バッファのバッファfdに対してmmapを実行し、ユーザー空間からアクセスできる入力バッファアドレスを取得します。
2. 手順1で取得した入力バッファアドレスを使用して、入力画像を入力バッファに格納します。
3. NPU_NET_IOCTL_RUNというIOCTLをネットワークfdに配信します。
 
2つ以上のニューラルネットワークが実行される場合、NPUデバイスドライバは時分割アルゴリズムでニューラルネットワークを実行します。
この場合、実行順序はqueue.fコマンドを使用して内部的にスケジュールされるため、ニューラルネットワークはユーザー空間から要求された順序で実行されます。
 
 
<br/><br/><br/>
 
## 2.1 NPU Linuxデバイスドライバのソースコード
---
- {TOPST_PATH}/build/ai-g-topst/tmp/work/ai_g_topst-telechips-linux/linux-topst/5.10.223-r0/git/drivers/misc/telechips/npu
 
    - npu.c
    - npu.h
    - npu_def.h
    - npu_reg.h
 
<br/><br/><br/>
 
## 2.2 デバイスツリー
---
以下の例は、AI-GでNPUデバイスドライバを使用するためのデバイスツリーです。
 
```
# NPU device tree example
 
 npu0: npu@11000000 {
                compatible = "telechips,npu";
                reg = <0x0 0x11000000 0x0 0x400>;
                interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
                clocks = <&fbus_npu FBUS_NPU_0_ACLK &fbus_npu FBUS_NPU_PCLK
                &fbus_npu FBUS_NPU_0_CCLK &fbus_npu FBUS_NPU_0_CPUCLK >;
                clock-names = "npubus_aclk", "npubus_pclk", "npubus_cclk", "npubus_cpu";
                disable-ue-fail = <0>;
                disable-ce-fail = <0>;
                disable-wdt = <0>;
                /* <800000000> is 1000ms for timeout at 800MHz of MLX */
                wdt-timeout-count = <800000000>;
                /* <400000000> is 500ms for re-arm interval at 800Mhz of MLX */
                wdt-rearm-count = <400000000>;
                work-buffer-size = <200000000>;
                status = "disabled";
        };
 
 
 npu1: @11000400 {
                compatible = "telechips,";
                reg = <0x0 0x11000400 0x0 0x400>;
                interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
                clocks = <&fbus_npu FBUS_NPU_1_ACLK &fbus_npu FBUS_NPU_PCLK
                &fbus_npu FBUS_NPU_1_CCLK &fbus_npu FBUS_NPU_1_CPUCLK >;
                clock-names = "npubus_aclk", "npubus_pclk", "npubus_cclk", "npubus_cpu";
                disable-ue-fail = <0>;
                disable-ce-fail = <0>;
                disable-wdt = <0>;
                /* <800000000> is 1000ms for timeout at 800MHz of MLX */
                wdt-timeout-count = <800000000>;
                /* <400000000> is 500ms for re-arm interval at 800Mhz of MLX */
                wdt-rearm-count = <400000000>;
                work-buffer-size = <200000000>;
                status = "disabled";
        };
 
```
 
<br/>
 
|     プロパティ     |              説明              |
|------------------|---------------------------------------|
| compatible       | “telechips,npu” に固定              |
| reg              | NPUレジスタのベースアドレスとサイズ    |
| disable-ue-fail  | UEエラーによる失敗を無効にします。<br>disable-ue-failが0の場合、UEエラーが検出されるとfailが返されます。<br>または <br>disable-ue-failが0x7の場合、UEエラーは無視されます。                                      |
| disable-ce-fail  | CEエラーによる失敗を無効にします。<br>disable-ce-failが0の場合、CEエラーが検出されるとfailが返されます。<br>または <br>disable-ce-failが0x7の場合、CEエラーは無視されます。                                           |
| disable-wdt      |  ウォッチドッグタイマーを無効にします               |
| wdt-timeout-count| ウォッチドッグタイムアウトカウント                |
| wdt-rearm-count  | ウォッチドッグリアームカウント<br>この値はウォッチドッグタイムアウトカウントより小さくする必要があります。   |
| reg-names        | NPUレジスタ名                     |
| work-buffer-size | ワークバッファ割り当てサイズ           |
| interrupt-parent | 割り込みコントローラデバイスツリーノード |
| interrupts       | 割り込み番号                      |
 
<br/><br/><br/>
 
## 2.3 IOCTLコマンド
---
AI-GのNPUを使用するために提供されるIOCTLコマンドは以下のとおりです。
 
<br/><br/>
 
### 2.3.1 NPUファイル記述子のIOCTLコマンド
 
NPUファイル記述子は、/dev/npu0や/dev/npu1などのNPUデバイスファイルを開くことで取得できます。使用可能なIOCTLコマンドは以下のとおりです。
 
 
|      コマンド           |        引数         |        説明      |
|------------------------|-------------------------|-------------------------|
| NPU_IOCTL_ALLOC_BUFFER | struct buf_alloc_req*  | CMAバッファの割り当て     |
| NPU_IOCTL_LOAD_NETWORK | struct net_load_req*   | ネットワークのロード            |
| NPU_IOCTL_READ_REG     | struct reg_access_req* | レジスタから値を読み取る |
| NPU_IOCTL_WRITE_REG    | struct reg_access_req* | レジスタに値を書き込む |
| NPU_IOCTL_RESET_NPU    | struct npu_init_req*   | NPUのリセット               |
| NPU_IOCTL_WRITE_TEST_CFG| test_cfg_wr_req_t*    | ecc_testの書き込み      |
| NPU_IOCTL_READ_NPU_ERR | npu_err_rd_req_t*      | ECCとWDTの読み取り        |
 
<br/>
 
NPU_IOCTL_ALLOC_BUFFERコマンド
- 構造体buffer_alloc_reqを介して配信されたサイズ値を使用してCMAバッファを割り当て、
- バッファファイル記述子を返します。
 
NPU_IOCTL_LOAD_NETWORKコマンド
- 構造体net_load_reqを介して配信されたパラメータを格納するためのCMAバッファを割り当て、
- 割り当てられたCMAバッファにパラメータをコピーし、
- ネットワークファイル記述子を返します。
 
NPU_IOCTL_WRITE_TEST_CFGとNPU_IOCTL_READ_NPU_ERRは、test_cfg_wr_req_tを介して送信されるNPUテストパラメータ値であり、どちらもテスト結果値を読み取るために使用されます。
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_ALLOC_BUFFER</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>struct buf_alloc_req</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>入出力用のCMAバッファを作成し、それにアクセスするためのfdを返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>バッファが割り当てられていない: EINVAL </p>
<p>ファイル記述子番号: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_LOAD_NETWORK</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>struct net_load_req</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>構造体net_load_reqを介して配信されたパラメータを格納するためのCMAバッファを割り当て、
割り当てられたCMAバッファにパラメータをコピーし、
ネットワークファイル記述子を返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>ネットワークファイル記述子を生成できない: EINVAL</p>
<p>ファイル記述子番号: 成功</p></td>
</tr>
</tbody>
</table>

<br/><br/>

<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_READ_REG</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>struct reg_access_req</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>reg_access_reqを介して渡されたレジスタアドレスから値を読み取ります。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>レジスタ読み取り失敗: EINVAL</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_WRITE_REG</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>struct reg_access_req</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>reg_access_reqを介して渡されたレジスタアドレスに値を書き込みます。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>レジスタ書き込み失敗: EINVAL</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_RESET_NPU</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>npu_init_req_t</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>NPUをリセットします。arg値が0でない場合、ハードリセットを実行します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_WRITE_TEST_CFG</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>test_cfg_wr_req_t</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>test_cfg_wr_req_tを介して渡されたecc_test_crtl、mlx_err_inj_mask_data、およびmlx_err_inj_mask_parの値をエラー注入レジスタに書き込みます。</p>
<p>wdt_ext_cntとwdt_int_cntの値は、WDTのタイムアウトおよびリアームカウント値として書き込まれます。</p>
<p>さらに、test_cfg_wr_req_tを介して配信されたmlx_bin_idx値に従って、mlx sramにロードされるファイルが選択されます。</p>
 
</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_IOCTL_READ_NPU_ERR</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>npu_err_rd_req_t</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>ECCおよびWDTステータスレジスタの値を読み取ります。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
### 2.3.2 ネットワークファイル記述子のIOCTLインターフェース
 
ネットワークファイル記述子は、NPU_IOCTL_LOAD_NETWORKコマンドをNPUファイル記述子に渡すことで作成できます。pollやcloseなどの操作をサポートしています。使用可能なIOCTLコマンドは以下のとおりです。
 
<br/>
 
|         コマンド            |         引数         |         説明      |
|----------------------------|--------------------------|--------------------------|
| NPU_NET_IOCTL_RUN          | struct net_run_req*     | 推論の実行            |
| NPU_NET_IOCTL_PROFILE      | struct net_profile_req* | 推論サイクルのプロファイル |
| NPU_NET_IOCTL_SET_COLOR_FMT | int                      | 入力カラーフォーマットの設定   |
 
<br/>
 
NPU_NET_IOCTL_RUNが実行されると、NPUドライバはネットワークを実行するコマンドをNPU HWに送信し、推論が終了する時点はpollを呼び出すことで確認できます。
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_NET_IOCTL_RUN</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>struct net_run_req*</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>net_run_reqを介して渡された入出力バッファを使用して推論が実行されます。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>推論実行失敗: EINVAL</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_NET_IOCTL_PROFILE</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>struct net_profile_req* </td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>net_run_reqを介して渡された入出力バッファを使用して推論が実行されます。NPU操作が完了するまでに必要なサイクルを返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>推論実行失敗: EINVAL</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>コマンド</strong></td>
<td>NPU_NET_IOCTL_SET_COLOR_FMT</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>int arg</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>ネットワークの入力カラーフォーマットを指定します。</p>
<p>argとしてNPU_COLOR_YUVまたはNPU_COLOR_RGB以外の値が渡された場合、エラーが返されます。</p></td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>-errorcode: 失敗</p>
<p>EINVAL: カラーフォーマット指定失敗</p>
<p>0: 成功</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
### 2.3.3 バッファファイル記述子のIOCTLインターフェース
 
バッファファイル記述子:
- NPU_IOCTL_ALLOC_BUFFERコマンドをNPUファイル記述子に送信することで生成できます。
- mmap、closeなどの操作をサポートします。
- IOCTLコマンドはサポートしていません。
- mmap操作を介してユーザーモードからCMAバッファを取得します。
- close操作を介してCMAバッファを解放します。

<br/><br/><br/><br/>

# 3. NPU API
---
Linux APIは、より高レベルのC関数を使用してNPUを制御する目的で提供されており、Linux APIを介したNPUの使用フローは次のとおりです。
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Software/NPU%20development/NPU_API/1.%20NPU%20API.png"></p>
<p align="center"><strong>図 3.1 NPU API</strong></p>
 
提供されるNPU APIは次のとおりです。
 
<br/><br/><br/>
 
## 3.1 NPUサンプルアプリケーションコード
---
AI-G SDKでNPUテストを行うためのサンプルコードを入手できます。
 
- {TOPST_PATH}/build/tcc7500-main/tmp/work/cortexa53-telechips-linux/tc-nn-app/1.0.0-r0/git/
 
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>
<p><strong>├── common</strong></p>
<p><strong>│   ├── camera</strong></p>
<p><strong>│   │   ├── camera_api.c</strong></p>
<p><strong>│   │   └── camera_api.h</strong></p>
<p><strong>│   ├── display</strong></p>
<p><strong>│   │   ├── display_api.c</strong></p>
<p><strong>│   │   ├── display_api.h</strong></p>
<p><strong>│   │   ├── scaler_api.c</strong></p>
<p><strong>│   │   └── scaler_api.h</strong></p>
<p><strong>│   ├── message</strong></p>
<p><strong>│   │   ├── message_api.c</strong></p>
<p><strong>│   │   └── message_api.h</strong></p>
<p><strong>│   ├── utils</strong></p>
<p><strong>│   │   ├── opencv_api.c</strong></p>
<p><strong>│   │   ├── opencv_api.h</strong></p>
<p><strong>│   │   ├── perf_api.c</strong></p>
<p><strong>│   │   ├── perf_api.h</strong></p>
<p><strong>│   │   ├── time_api.c</strong></p>
<p><strong>│   │   └── time_api.h</strong></p>
<p><strong>├── include</strong></p>
<p><strong>│   ├── NnError.h</strong></p>
<p><strong>│   └── NnType.h</strong></p>
<p><strong>├── src</strong></p>
<p><strong>│   ├── NnAppMain.c</strong></p>
<p><strong>│   ├── NnAppMain.h</strong></p>
<p><strong>│   ├── NnDebug.c</strong></p>
<p><strong>│   ├── NnDebug.h</strong></p>
<p><strong>│   ├── NnMemory.c</strong></p>
<p><strong>│   ├── NnMemory.h</strong></p>
<p><strong>│   ├── NnNeuralNetwork.c</strong></p>
<p><strong>│   ├── NnNeuralNetwork.h</strong></p>
<p><strong>│   ├── NnPerf.c</strong></p>
<p><strong>│   ├── NnPerf.h</strong></p>
<p><strong>│   ├── NnProtocolManager.c</strong></p>
<p><strong>│   ├── NnRtpm.c</strong></p>
<p><strong>│   ├── NnRtpm.h</strong></p>
<p><strong>│   ├── NnSignalHandler.c</strong></p>
<p><strong>│   └── NnSignalHandler.h</strong></p>
</tr>
</tbody>
</table>
 
<br/><br/><br/>
 
## 3.1.1 LinuxサンプルAPIソースコード
 
- {TOPST_PATH}/build/ai-g-topst/tmp/work/cortexa53-telechips-linux/libtcndnpu/1.0.0-r0/git/lib/
 
  - src/npu_api.c
  - include/npu_api.h
 
<br/><br/><br/>
 
## 3.2 NPUデバイス用API
---
<br/>
 
<table>
  <tr>
  <td>
    <strong>関数名</strong>
  </td>
  <td>
    npu_t* npu_open(int minor)
  </td>
  </tr>
  <tr>
    <td>
      <strong>パラメータ</strong>
    </td>
    <td>
     <p>minor:</p>
     <p>0: シングルクラスタ</p>
     <p>1: マルチクラスタ</p>
    </td>
  </tr>
  <tr>
    <td>
      <strong>説明
    </td>
    <td>
      NPUデバイスを開きます。
    </td>
  </tr>
  <tr>
    <td>
    <strong>戻り値</strong>
    </td>
    <td>
      NPUハンドル
    </td>
  </tr>
</table>
<br/><br/>
<table>
  <tr>
    <td>
      <strong>関数名</strong>
    </td>
    <td>
      int npu_reset(npu_t* npu, int soft_reset, npu_ecc_wdt_cfg_t* param)
    </td>
  </tr>
  <tr>
    <td>
      <strong>パラメータ</strong>
    </td>
    <td><p>npu: NPUハンドル</p>
    <p>soft_reset:</p>
    <p>0: ハードリセット</p>
    <p>1: ソフトリセット</p>
    <p>param: デバイスツリーから読み取ったECCおよびWDTの設定 </p></td>
  </tr>
  <tr>
    <td>
      <strong>説明</strong>
    </td>
    <td>
      NPUデバイスにリセットコマンドを送信します。
    </td>
  </tr>
  <tr>
    <td>
      <strong>戻り値</strong>
    </td>
    <td>
      <p>0: 成功</p>
      <p>-1: 失敗</p>
    </td>
  </tr>
</table>
 
<br/><br/>
 
<table>
  <tr>
    <td>
      <strong>関数名</strong>
    </td>
    <td>
      int npu_close(npu_t* npu)
    </td>
  </tr>
  <tr>
    <td>
      <strong>パラメータ</strong>
    </td>
    <td>
      npu: NPUハンドル
    </td>
  </tr>
  <tr>
    <td>
      <strong>説明</strong>
    </td>
    <td>
      NPUデバイスハンドルのリソースを解放します。
    </td>
  </tr>
  <tr>
    <td>
      <strong>戻り値</strong>
    </td>
    <td>
      <p>0: 成功</p>
      <p>-1: 失敗</p>
    </td>
  </tr>
</table>

<br/><br/>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int npu_read_reg(npu_t* npu, unsigned int addr, unsigned int *data)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPUハンドル</p>
<p>addr: レジスタアドレス</p>
<p>data: レジスタデータ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>NPUデバイスのレジスタ値を読み取ります。</p>
<p>- レジスタアドレスがパラメータaddrに配信されると、読み取られた値がdataを介して返されます。</p> </td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int npu_write_reg(npu_t* npu, unsigned int addr, unsigned int data)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPUハンドル</p>
<p>addr: レジスタアドレス</p>
<p>data: レジスタデータ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>NPUデバイスのレジスタにデータ値を書き込みます。</p>
<p>レジスタアドレスとデータは、それぞれパラメータaddrとdataとして送信されます。</p></td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int npu_write_test_cfg(npu_t* npu, npu_chiptest_t* cfg_param)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPUハンドル</p>
<p>cfg_param: ECCおよびWDTの構成パラメータ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>ECCとWDTの設定値は、npu_chiptest_tパラメータの値に変更されます。
そして、変更されたECCとWDTの設定値は、npu_reset()を実行した後にNPU ECCとWDTに適用されます。
<pre >
typedef struct {
      unsigned int mlx_bin_idx;
      unsigned int wdt_ext_cnt;
      unsigned int wdt_int_cnt;
      unsigned int ecc_test_ctrl;
      unsigned int mlx_err_inj_mask_data;
      unsigned int mlx_err_inj_mask_par;
} npu_chiptest_t;
</pre>
</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
<br/><br/>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int npu_read_err_status(npu_t* npu, npu_err_status_t* param)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPU handle</p>
<p>param: status register value and interrupt reason value</p></td>
</tr>
<tr class="odd">
<td><strong>Description</strong></td>
<td>NPU ECC, WDT status register values, and interrupt reason values are read.
<pre >
typedef struct {
      npu_ecc_cbuf_t cbuf;
      npu_ecc_gbuf_t gbuf[NUM_NPU_CORE];
      npu_ecc_sram_t sram[NUM_NPU_CORE];
      unsigned int wdt_to;
      unsigned int irq_reason;
} npu_err_status_t;
</pre>
</td>
</tr>
<tr class="even">
<td><strong>Return</strong></td>
<td><p>0: Success</p>
<p>-1: Failure</p></td>
</tr>
</tbody>
</table>
<br/><br/><br/>


## 3.3 API for Buffer
---
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>npu_buf_t* buffer alloc(npu_t* npu, int size)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPUハンドル</p>
<p>size: CMAバッファサイズ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>引数に渡されたサイズのCMAバッファを割り当てます。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>バッファハンドル: 成功</p>
<p>NULL: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>void* buffer_get_addr(npu_buf_t* buf)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>buf: バッファハンドル</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>バッファハンドルからCMAバッファポインタを取得します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>CMAバッファポインタ: 成功</p>
<p>NULL: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
  <tr>
    <td>
      <strong>関数名</strong>
    </td>
    <td>
      int buffer_close(npu_buf_t* buf)
    </td>
  </tr>
  <tr>
    <td>
      <strong>パラメータ</strong>
    </td>
    <td>
      buf: バッファハンドル
    </td>
  </tr>
  <tr>
    <td>
      <strong>説明</strong>
    </td>
    <td>
      CMAバッファのリソースを解放します。
    </td>
  </tr>
  <tr>
    <td>
      <strong>戻り値</strong>
    </td>
    <td>
      <p>0: 成功</p>
      <p>-1: 失敗</p>
    </td>
  </tr>
</table>
 
<br/><br/><br/>
 
## 3.4 ネットワーク用API
---
<br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>npu_net_t* network_load_from_file(npu_t* npu, char* sofile, char* cmdfile, char* paramfile)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPUハンドル</p>
<p>sofile: ネットワーク共有オブジェクト 例) net.so</p>
<p>cmdfile: ネットワークコマンド 例) npu_cmd.bin</p>
<p>paramfile: ネットワークの重み 例) quantized_network.bin</p>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>引数に渡されたsofile、cmdfile、paramfileを使用してネットワークハンドルを作成します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>ネットワークハンドル: 成功</p>
<p>NULL: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>npu_net_t* network_load(npu_t* npu, char* cmd, int cmd_size, char* param, int param_size)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>npu: NPUハンドル</p>
<p>cmd: ネットワークコマンドバッファ</p>
<p>cmd_size: ネットワークコマンドバッファサイズ</p>
<p>param: ネットワーク重みバッファ</p>
<p>param_size: ネットワーク重みバッファサイズ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>network_load_from_fileとは異なり、ネットワークハンドルはバッファから生成されます。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>ネットワークハンドル: 成功</p>
<p>NULL: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_set_color_format(npu_net_t* net, int color_format)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>net: ネットワークハンドル</p>
<p>color_format : NPU_COLOR_RGB または NPU_COLOR_YUV</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>ネットワークの入力カラーフォーマットを指定するために使用されます。</p>
<p>network_set_color_formatが呼び出されない場合、デフォルトでNPU_COLOR_RGBフォーマットが入力フォーマットとして選択されます。</p></td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-errorcode: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_run(npu_net_t* net, npu_buf_t* in, npu_buf_t* out, 
npu_ecc_wdt_status_t* ecc_wdt_status, int timeout_in_ms)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>net: ネットワークハンドル</p>
<p>in: ネットワーク入力バッファ (buffer alloc() から)</p>
<p>out: ネットワーク出力バッファ (buffer alloc() から)</p>
<p>ecc_wdt_status: ECCおよびWDTのステータス情報</p>
<p>timeout_in_ms: 推論タイムアウト設定時間 (ms)</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>NPUを介してネットワーク上で推論を実行します。</p>
<p>network_runは、network_issue_runとnetwork_wait_doneを連続して呼び出すのと同じように動作します。</p>
<div>
  - インスタンスがtimeout_in_ms以内に正常に完了した場合、0を返します。<br>
  - エラーが発生した場合、-1を返します。
</div>
<br/>
<p>推論プロセス中に生成されたECCおよびWDTのステータス情報をecc_wdt_statusバッファを介して受信します。</p>
<br/>
<pre >
typedef union err_bits {
    struct {
        unsigned int ce_sram  : 1; /**< ECC CE in MLX SRAM */
        unsigned int ce_gbuf  : 1; /**< ECC CE in GBuf */
        unsigned int ce_cbuf  : 1; /**< ECC CE in Cmd buffer */
        unsigned int ce_rsv   : 1; /**< Reserved */
        unsigned int ue_sram  : 1; /**< ECC UE in MLX SRAM */
        unsigned int ue_gbuf  : 1; /**< ECC UE in GBuf */
        unsigned int ue_cbuf  : 1; /**< ECC UE in Cmd buffer */
        unsigned int ue_rsv   : 1; /**< Reserved */
        unsigned int wdt_to   : 1; /**< WDT Time-out */
    };
} err_bits_t;
      </pre>
</td>
 
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-errorcode: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_run_sync(npu_net_t* net, npu_buf_t* in, npu_buf_t* out,
npu_err_bits_t* status, npu_perf_t* perf)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>net: ネットワークハンドル</p>
<p>in: ネットワーク入力バッファ (buffer alloc() から)</p>
<p>out: ネットワーク出力バッファ (buffer alloc() から)</p>
<p>status: 実行後のエラーフラグ </p>
<p>perf: パフォーマンスデータ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>提供された入出力バッファを使用して、NPU上で同期推論を実行します。</p>
<p>この関数は、推論が完了するまでブロックし、perf構造体を介して詳細なパフォーマンスメトリック (DMA、計算、合計時間) を返します。
</p>
<pre >
typedef struct
{ 
    int elapsed_in_us;
    int dma;
    int comp;
    int all;
} npu_perf_t;
</pre>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-errorcode: 失敗</p></td>
</tr>
</tbody>
</table>
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_run_async(npu_net_t* net, npu_buf_t* in, npu_buf_t* out,
npu_err_bits_t* status, npu_perf_t* perf)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>net: ネットワークハンドル</p>
<p>in: ネットワーク入力バッファ (buffer alloc() から)</p>
<p>out: ネットワーク出力バッファ (buffer alloc() から)</p>
<p>status: 実行後のエラーフラグ </p>
<p>perf: パフォーマンスデータ</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>NPU上で非同期推論を実行します。</p>
<p>経過時間はユーザー空間でclock_gettime()を使用して測定され、perf構造体に格納されます (DMAおよび計算フィールドは入力されません)。
</p>
<pre >
typedef struct
{ 
    int elapsed_in_us;
    int dma;
    int comp;
    int all;
} npu_perf_t;
</pre>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-errorcode: 失敗</p></td>
</tr>
</tbody>
</table>
<br/><br/>

<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_issue_run(npu_net_t* net, npu_buf_t* in, npu_ecc_wdt_status_t* status, npu_buf_t* out)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>net: ネットワークハンドル</p>
<p>in: ネットワーク入力バッファ (buffer alloc() から)</p>
<p>status: ECCおよびWDTのステータス情報</p>
<p>out: ネットワーク出力バッファ (buffer alloc() から)</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>推論を開始するためにNPU HWにコマンドを送信します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-errorcode: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_wait_done(npu_net_t* net, int timeout_in_ms)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td><p>net: ネットワークハンドル</p>
<p>timeout_in_ms: 推論タイムアウト設定時間 (ms)</p></td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td><p>network_wait_doneは、NPUでの推論が終了するのを待ちます。</p>
<p>timeout_is_ms以内に推論が終了した場合、0が返されます。</p></td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>0: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_get_input_width(npu_net_t* net)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>net: ネットワークハンドル</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>必要なネットワーク入力幅を返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>ネットワーク入力バッファサイズ: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_get_input_height(npu_net_t* net)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>net: ネットワークハンドル</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>必要なネットワーク入力高さを返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>ネットワーク入力バッファサイズ: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
 
 
<br/><br/>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_get_input_size(npu_net_t* net)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>net: ネットワークハンドル</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>必要なネットワーク入力バッファサイズを返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>ネットワーク入力バッファサイズ: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_get_output_size(npu_net_t* net)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>net: ネットワークハンドル</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>必要なネットワーク出力バッファサイズを返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>ネットワーク出力バッファサイズ: 成功</p>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>関数名</strong></td>
<td>int network_get_type(npu_net_t* net)</td>
</tr>
<tr class="even">
<td><strong>パラメータ</strong></td>
<td>net: ネットワークハンドル</td>
</tr>
<tr class="odd">
<td><strong>説明</strong></td>
<td>network_get_typeは、ネットワークのクラス (タイプ) を返します。</td>
</tr>
<tr class="even">
<td><strong>戻り値</strong></td>
<td><p>クラス (タイプ): 成功</p>
<pre >
enum {
        ENLIGHT_POST_NONE,
        ENLIGHT_POST_CLASSIFIER,
        ENLIGHT_POST_DETECTOR,
        ENLIGHT_POST_CUSTOM
}; 
</pre>
<p>-1: 失敗</p></td>
</tr>
</tbody>
</table>
 
<br/><br/>
 
<table>
  <tr>
    <td>
      <strong>関数名</strong>
    </td>
    <td>
      int network_run_postprocess(npu_net_t* net, npu_buf_t* out, void* result)
    </td>
  </tr>
  <tr>
    <td>
      <strong>パラメータ</strong>
    </td>
    <td>
      <p>net: ネットワークハンドル</p>
      <p>out: ネットワーク出力バッファ</p>
      <p>result: 処理結果</p>
    </td>
  </tr>
  <tr>
    <td>
      <strong>説明</strong>
    </td>
    <td>
      <p>sofileを使用してネットワークが作成された場合にのみ動作します。</p>
      <p>後処理を実行します。</p>
      <p>処理結果を返します。</p>
    </td>
  </tr>
  <tr>
    <td>
      <strong>戻り値</strong>
    </td>
    <td>
      0
    </td>
  </tr>
</table>
 
<br/><br/>
 
<table>
  <tr>
    <td>
      <strong>関数名</strong>
    </td>
    <td>
      int network_close(npu_net_t* net)
    </td>
  </tr>
  <tr>
    <td>
      <strong>パラメータ</strong>
    </td>
    <td>
      net: ネットワークハンドル
    </td>
  </tr>
  <tr>
    <td>
      <strong>説明</strong>
    </td>
    <td>
      network_close()はネットワークのリソースを解放し、0を返します。
    </td>
  </tr>
  <tr>
    <td>
      <strong>戻り値</strong>
    </td>
    <td>
      0
    </td>
  </tr>
</table>
