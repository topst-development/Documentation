# 1. はじめに
---
本書では、AI-Gの使用例を紹介します。
本書には以下の情報が含まれています：
- ビデオ出力
  - MIPI DSI
- カメラ接続
  - MIPI CSI
- ストレージ接続
  - NVMe M.2 SSD
- イーサネット接続
- 40ピンGPIOヘッダー
  - 利用可能なセンサーとデバイス
<br/><br/><br/><br/>


# 2. ビデオ出力
---
AI-Gは、MIPI DSI-2インターフェースを介したビデオ出力をサポートしています。
15ピンFFCコネクタを介して2レーンのDSI接続を提供し、互換性のあるMIPI DSI LCDパネルへの接続に適しています。このインターフェースにより、グラフィカルユーザーインターフェース、ビデオ再生、および組み込みディスプレイ上のリアルタイムAI視覚化のスムーズなレンダリングが可能になります。
<br/><br/><br/>

## 2.1 MIPI DSI
---
DSIはDisplay Serial Interfaceの略で、プロセッサから外部スクリーンにディスプレイデータを送信するためにMIPI Allianceによって定義された規格です。組み込みLCDパネルに適した高速かつ低電力の通信を可能にします。
前述のように、AI-Gは15ピンFFCコネクタを介して2レーンのDSI接続を提供し、GUIレンダリング、ビデオ再生、またはリアルタイム推論の視覚化のために互換性のあるMIPI DSIディスプレイモジュールへの接続を可能にします。
<br/><br/>

### 2.1.1 5インチ DSI ディスプレイ
Elecrow 5インチ DSIディスプレイは、IPSパネルと静電容量式タッチサポートを備えた800×480解像度のLCDで、Raspberry PiのMIPI DSIインターフェースで使用するために設計されています。プラグアンドプレイ機能のおかげで、追加のドライバインストールは必要ありません。ディスプレイは15ピンMIPI DSIコネクタを介してAI-Gボードに接続され、インターフェースを介して直接電力が供給されるため、外部電源は不要です。
このモジュールは、AI-Gプラットフォーム上のGUIベースのアプリケーション、リアルタイムモニタリング、およびインタラクティブなAIデモに適しています。

DSIディスプレイの仕様は以下の通りです：

| 仕様                | 説明                                |
| ------------------- | -------------------------------------------|
| ディスプレイサイズ        | 5 インチ                                     |
| 解像度          | 800 x 480                                  |
| リフレッシュレート        | 60 Hz                                      |
| インターフェース (ディスプレイ) | MIPI DSI                                   |
| インターフェース (パネル)   | RGB888 ポート                                |
| 動作電圧   | 3.3V                                      |
| 動作温度範囲| -20 °C ～ 70 °C                            |
| ケーブルタイプ          | フラットフレキシブルケーブル (FFC) (15ピン)                               |
| 互換性       | Raspberry Pi および AI-G (MIPI DSIインターフェース経由)|

以下の手順に従ってDSIディスプレイをテストできます：

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%205.%20display.png" width="400"></p>
<p align="center"><strong>図 2.1 5インチ DSI ディスプレイ </strong></p><br/>

#### ステップ 1. ディスプレイをAI-GボードのMIPI DSIに接続する
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%206.%20Connecting%20Display%20to%20AI-G.png" width="500"></p>
<p align="center"><strong>図 2.2 ディスプレイをAI-Gボードに接続 </strong></p><br/>

#### ステップ 2. AI-GボードでのMIPI DSI接続の確認
ディスプレイがAI-Gボードに正しく接続されているか確認するには、以下のコマンドを入力して確認してください。
```
$ dmesg | grep -i display
```

**注**: ディスプレイを接続し、ボードの電源を入れます。ボードの電源が既に入っている場合は、ディスプレイを接続した後にボードを再起動してください。
<br/><br/><br/><br/>


# 3. カメラ接続
---
AI-Gは、MIPI CSI-2インターフェースを介したカメラ入力をサポートしています。
デフォルトでは、15ピンコネクタを介して2レーンのCSI接続を提供します。高解像度や高フレームレートのAIビジョンタスクなど、より高い帯域幅を必要とするアプリケーションのために、オプションの20ピンコネクタを介した4レーン構成もサポートされています。
<br/><br/><br/>

## 3.1 MIPI CSI
---
CSIはCamera Serial Interfaceの略で、カメラモジュールをホストプロセッサに接続するためにMIPI Allianceによって定義された標準インターフェースです。カメラからプロセッサへの画像データの高速かつ低電力の送信を可能にします。
上記のように、AI-Gはデフォルトで2レーンのCSI接続を提供し、より高いデータスループットのために20ピンコネクタを介した4レーン構成のオプションサポートも提供します。

現在、AI-GはArduCam (5 MP) および Raspberry Pi v1 カメラ (5 MP) モジュールのみをサポートしています。
<br/><br/>

### 3.1.1 ArduCam
ArduCamは、組み込みシステムおよびAIアプリケーション向けに設計された多用途のカメラモジュールです。MIPI CSIを含むさまざまなイメージセンサーとインターフェースをサポートしており、AI-Gのような開発ボードとの統合に適しています。
AI-Gは、2レーンまたは4レーンのMIPI CSIインターフェースを備えたArduCamモジュールをサポートし、物体検出や画像分類などのAIビジョンタスクのための安定した画像入力を可能にします。FFCケーブルとの互換性のおかげで、ArduCamモジュールはAI-GボードのCSIコネクタに簡単に接続でき、エッジAIシステムでのリアルタイムカメラ入力のための信頼性の高いソリューションを提供します。

ArduCamモジュールの仕様は以下の通りです：

| 仕様                     | 説明                                 |
| ------------------------ | ------------------------------------------- |
| センサー                   | OV5647 (5 メガピクセル)                        |
| 解像度               | 2592 × 1944 (フル 5MP)                      |
| サポートされている出力フォーマット | RAW, YUV, JPEG (センサーに依存)           |
| インターフェース                | MIPI CSI                                    |
| フレームレート               | 1080pで最大30fps、720pで60fps         |
| レンズマウント               | 固定焦点レンズ (標準)                 |
| 視野角 (FOV)      | 約 54° ～ 70° (モデルにより異なる)         |
| 接続タイプ          | FFC                   |
| 動作電圧        | 3.3V (標準)                              |
| フォームファクタ              | コンパクトPCB、約 25 mm x 24 mm                   |
| 互換性            | Raspberry Pi および AI-G (MIPI CSIポート経由)      |
| 追加機能      | 低消費電力、プラグアンドプレイモジュール |

以下の手順に従ってArduCamをテストできます：

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%201.%20arducam.png" width="400"></p>
<p align="center"><strong>図 3.1 ArduCam </strong></p><br/>

#### ステップ 1. ArduCamをAI-GボードのMIPI CSIに接続する
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%202.%20Connecting%20Cam%20to%20AI-G.png" width="500"></p>
<p align="center"><strong>図 3.2 ArduCamをAI-Gボードに接続 </strong></p><br/>

#### ステップ 2. AI-GボードでのMIPI CSI接続の確認
ArduCamがAI-Gボードに正しく接続されているか確認するには、以下のコマンドを入力して確認してください。
```
$ dmesg | grep -i "ov5647"
```

**注**: カメラを接続し、ボードの電源を入れます。ボードの電源が既に入っている場合は、カメラを接続した後にボードを再起動してください。
<br/><br/>


### 3.1.2 Raspberry Pi v1 カメラ
Raspberry Pi Camera Module v1は、Raspberry Pi財団によって開発されたコンパクトな5 MPカメラです。OmniVision OV5647イメージセンサーに基づいており、フラットフレキシブルケーブル (FFC) を使用してMIPI CSI-2インターフェースを介してホストボードに接続します。

もともとRaspberry Piシリーズ用に設計されたこのモジュールは、15ピンMIPI CSIコネクタを介してAI-Gとも互換性があります。画像キャプチャ、ビデオストリーミング、AI-Gプラットフォーム上のAI駆動コンピュータビジョンタスクなどのエントリーレベルのカメラアプリケーションに信頼性の高いソリューションを提供します。

Raspberry Pi v1カメラモジュールの仕様は以下の通りです：

| 仕様                | 説明                              |
| ------------------- | ---------------------------------------- |
| センサー              | OmniVision OV5647                        |
| 解像度          | 2592 × 1944 (5 MP)                        |
| 出力フォーマット      | RAW, YUV, JPEG                           |
| インターフェース           | MIPI CSI                                 |
| フレームレート          | 1080p30, 720p60, VGA90                   |
| レンズ                | 固定焦点                              |
| 視野角 (FOV) | 最大 54°                                     |
| ケーブルタイプ          | FFC (15ピン)                             |
| ボード寸法    | 25 mm x 24 mm                              |
| 互換性       | Raspberry Pi および AI-G (MIPI CSIポート経由)   |

以下の手順に従ってRaspberry Pi v1カメラをテストできます：

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%203.%20raspv1cam.png" width="400"></p>
<p align="center"><strong>図 3.3 Raspberry Pi v1 カメラ </strong></p><br/>

#### ステップ 1. Raspberry Pi v1カメラをAI-GボードのMIPI CSIに接続する
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%202.%20Connecting%20Cam%20to%20AI-G.png" width="500"></p>
<p align="center"><strong>図 3.4 Raspberry Pi v1カメラをAI-Gボードに接続 </strong></p><br/>

#### ステップ 2. AI-GボードでのMIPI CSI接続の確認
Raspberry PiカメラがAI-Gボードに正しく接続されているか確認するには、以下のコマンドを入力して確認してください。
```
$ dmesg | grep -i "ov5647"
```

**注**: カメラを接続し、ボードの電源を入れます。ボードの電源が既に入っている場合は、カメラを接続した後にボードを再起動してください。
<br/><br/><br/><br/>


# 4. ストレージ接続
---
この章では、AI-Gボードをさまざまなストレージデバイスに接続する方法について説明します。サポートされているストレージオプションには、PCIe経由の外部ストレージが含まれます。
<br/><br/><br/>

## 4.1 NVMe M.2 SSD
---
AI-Gは、PCIeスロットを介してM.2 SSDストレージデバイスをサポートしています。

#### ステップ 1. SSDの接続
- NVMe SSD (M.2 PCIe): NVMe M.2 SSDをAI-GボードのPCIeスロットに挿入します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/4.2.1%20AI-G%20NVME%20M.2%20SSD%20connection.png" width="600"></p>
<p align="center"><strong>図 4.1 NVMe M.2 SSDをAI-Gボードに接続 </strong></p><br/>

#### ステップ 2. AI-Gの起動
**reboot**コマンドを実行した後、ブートログを観察して、PCIeデバイスがシステムによって認識されていることを確認します。
**"telechips-pcie: Link up"**などのメッセージを探します。これは、PCIeリンクが正常に確立されたことを示します。

```
$ reboot
...
Starting kernel ...

[    1.207844] telechips-pcie 12000000.pcie: invalid resource
[    1.232395] telechips-pcie 12000000.pcie: Link up
[    1.521983] debugfs: Directory '18300000.dma' with parent 'dmaengine' already present!
[    1.531159] debugfs: Directory '18310000.dma' with parent 'dmaengine' already present!
[    1.540282] debugfs: Directory '18320000.dma' with parent 
...
ai-g-topst login: 
```

#### ステップ 3. SSD認識の確認

```
root@ai-g-topst:~# lspci
00:00.0 PCI bridge: Synopsys, Inc. Device 750b (rev 01)
01:00.0 Non-Volatile memory controller: Silicon Motion, Inc. SM2263EN SM2263XT SSD Controller (rev 03)
```

#### ステップ 4. SSDのマウント
```
$ fdisk /dev/nvme0n1
Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): 
```

fdiskプロンプト内で以下のキーを順番に入力します：

- o — 新しい空のDOSパーティションテーブルを作成します（オプション、既存のテーブルをクリアします）

- n — 新しいパーティションを追加します

- p — プライマリパーティションを選択します

- 1 — パーティション番号を1に設定します

- Enterを押す — デフォルトの最初のセクタを受け入れます

- Enterを押す — デフォルトの最後のセクタを受け入れます（ディスク全体を使用）

- w — パーティションテーブルを書き込んで終了します

```
$ mkfs.ext4 /dev/nvme0n1p1

$ mkdir -p /mnt/nvme

$ mount /dev/nvme0n1p1 /mnt/nvme
```

#### ステップ 5. 実行結果
この出力は、NVMe SSDデバイス (/dev/nvme0n1p1) がシステムによって正常に検出され、/mnt/nvme にマウントされたことを確認します。
```
$ df -h

Filesystem            Size  Used Avail Use% Mounted on
devtmpfs              426M     0  426M   0% /dev
/dev/mmcblk0p4        330M  201M  103M  67% /
tmpfs                 100M     0  100M   0% /dev/shm
tmpfs                 274M  8.6M  265M  4% /run
tmpfs                 4.0M     0  4.0M  0% /sys/fs/cgroup
tmpfs                 684M     0  684M  0% /tmp
tmpfs                 684M   12K  684M  1% /var/volatile
tmpfs                 137M     0  137M  0% /run/user/0
/dev/nvme0n1p1        117G   24K  111G  1% /mnt/nvme
```
<br/><br/><br/><br/>

# 5. イーサネット接続
---
AI-Gは、オンボードのRJ45イーサネットポートを介したイーサネット接続をサポートしています。これにより、ボードは標準のTCP/IPプロトコルを使用してローカルネットワークまたはインターネットと通信できます。イーサネットは、リモートアクセス、データストリーミング、またはソフトウェア更新を必要とするAIアプリケーションの展開に一般的に使用されます。
<br/><br/><br/>

## 5.1 ルーター経由のネットワーク接続
---
この方法は、標準のルーターを使用してAI-Gをローカルネットワークに接続します。ボードは、DHCPを介して自動的にIPアドレスを取得するか、静的IPアドレスで構成できます。
<br/><br/>

### 5.1.1 ルートファイルシステムを読み取り/書き込みとして再マウント
ルートファイルシステムは読み取り専用としてマウントされています。以下のコマンドを使用して、構成ファイルを編集できるように書き込み権限で再マウントします：

```
$ mount -o remount,rw /
```
<br/><br/>


### 5.1.2 ネットワーク構成ファイルの作成
1. DHCPによる動的IP
/etc/systemd/network/20-wired.network ファイルを作成または編集し、以下の内容を含めてeth0インターフェースでDHCPを有効にします。

```
$ vi /etc/systemd/network/20-wired.network
 
[Match]
Name=eth0
 
[Network]
DHCP=yes
```

この構成は、systemd-networkdにeth0インターフェースのDHCPを介してIPアドレスを自動的に取得するように指示します。

2. 静的IP構成
静的IPアドレスを割り当てたい場合（たとえば、直接PC接続を使用する場合やDHCPサーバーが利用できない場合）、同じファイルを以下の内容で編集します：
```
$ vi /etc/systemd/network/20-wired.network

[Match]
Name=eth0

[Network]
Address=192.168.137.2/24
Gateway=192.168.137.1
DNS=8.8.8.8
```

これにより、IPアドレスが192.168.137.2に設定され、ゲートウェイとして192.168.137.1（Windows ICSで一般的）が使用され、Google DNSが構成されます。
<br/><br/>


### 5.1.3 ネットワークサービスの再起動
systemd-networkdサービスを再起動して、新しいネットワーク構成を適用します：

```
sudo systemctl restart systemd-networkd
```
<br/><br/>


### 5.1.4 ネットワーク接続の確認
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet4.png"></p>
<p align="center"><strong>図 5.1 ルーター経由のネットワーク接続</strong></p><br/>

GoogleのパブリックDNSサーバーにpingを実行して、インターネット接続をテストします：

```
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=113 time=30.208 ms
64 bytes from 8.8.8.8: seq=1 ttl=113 time=38.143 ms
64 bytes from 8.8.8.8: seq=2 ttl=113 time=30.969 ms
64 bytes from 8.8.8.8: seq=3 ttl=113 time=33.586 ms
 
```
<br/><br/><br/>


## 5.2 ホストPCとのネットワーク共有
---
Windowsオペレーティングシステムで利用可能なインターネット接続共有 (ICS) 機能を利用することで、ルーターを使用せずにPCのインターネット接続をAI-Gと共有できます。
<br/><br/>

### 5.2.1 ホストPCのネットワーク構成
- コントロールパネル → ネットワークとインターネット → ネットワーク接続 → イーサネットの設定
 
1. インターネットに接続されているネットワークアダプター（Wi-Fiなど）を見つけ、右クリックして**プロパティ**を選択します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet1.png" width="600"></p>
<p align="center"><strong>図 5.2 プロパティの選択</strong></p><br/>
 
2. 共有タブを選択します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet2.png" width="400"></p>
<p align="center"><strong>図 5.3 共有タブの選択</strong></p><br/>

3. 「ネットワークのほかのユーザーに、このコンピューターのインターネット接続をとおしての接続を許可する」というボックスにチェックを入れます。
 
4. ホームネットワーク接続のドロップダウンメニューで、AI-Gボードが接続するイーサネットアダプター（「イーサネット」など）を選択します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet3.png" width="400"></p>
<p align="center"><strong>図 5.4 イーサネットアダプターの選択</strong></p><br/>
 
5. **OK**をクリックして設定を保存します。

<br/><br/>

### 5.2.2 ルートファイルシステムを読み取り/書き込みとして再マウント
ルートファイルシステムは読み取り専用としてマウントされています。以下のコマンドを使用して、構成ファイルを編集できるように書き込み権限で再マウントします：

```
$ mount -o remount,rw /
```
<br/><br/>

### 5.2.3 ネットワーク構成ファイルの作成
1. DHCPによる動的IP
/etc/systemd/network/20-wired.network ファイルを作成または編集し、以下の内容を含めてeth0インターフェースでDHCPを有効にします。
```
$ vi /etc/systemd/network/20-wired.network
 
[Match]
Name=eth0
 
[Network]
DHCP=yes
```

この構成は、systemd-networkdにeth0インターフェースのDHCPを介してIPアドレスを自動的に取得するように指示します。

2. 静的IP構成
静的IPアドレスを割り当てたい場合（たとえば、直接PC接続を使用する場合やDHCPサーバーが利用できない場合）、同じファイルを以下の内容で編集します：
```
$ vi /etc/systemd/network/20-wired.network

[Match]
Name=eth0

[Network]
Address=192.168.137.2/24
Gateway=192.168.137.1
DNS=8.8.8.8
```
これにより、IPアドレスが192.168.137.2に設定され、ゲートウェイとして192.168.137.1（Windows ICSで一般的）が使用され、Google DNSが構成されます。

<br/><br/>

### 5.2.4 ネットワークサービスの再起動
systemd-networkdサービスを再起動して、新しいネットワーク構成を適用します：

```
sudo systemctl restart systemd-networkd
```

<br/><br/>

### 5.2.5 ネットワーク接続の確認
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet5.png"></p>
<p align="center"><strong>図 5.5 ホストPCとのネットワーク共有</strong></p><br/>

GoogleのパブリックDNSサーバーにpingを実行して、インターネット接続をテストします：

```
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=113 time=30.208 ms
64 bytes from 8.8.8.8: seq=1 ttl=113 time=38.143 ms
64 bytes from 8.8.8.8: seq=2 ttl=113 time=30.969 ms
64 bytes from 8.8.8.8: seq=3 ttl=113 time=33.586 ms
```

<br/><br/><br/><br/>

# 6. 40ピンGPIOヘッダー
---
AI-Gは40ピンGPIOヘッダーを備えており、さまざまなハードウェアプロジェクトに柔軟なI/O機能を提供します。
このヘッダーは、汎用入出力 (GPIO) 操作と互換性があり、センサー、LED、ボタン、その他の周辺機器を接続するために使用できます。

各ピンは、構成に応じてデジタルI/O、I2C、SPI、またはUART機能をサポートします。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.1%2040%20Pin%20GPIO%20Header%20Pinmap%20of%20AI-G.png" width="600"></p>
<p align="center"><strong>図 6.1 AI-Gの40ピンGPIOヘッダーピンマップ </strong></p><br/>

**注**: 外部ハードウェアを接続する前に、詳細なピン機能と電圧レベルについて公式のピン配置図を参照してください。
<br/><br/><br/><br/>

## 6.1 GPIO デジタル入出力
---
AI-Gボードは、40ピンヘッダーを介してデジタル入出力 (GPIO) をサポートしており、ユーザーはボタン、LED、センサーなどの外部デバイスと対話できます。
<br/><br/><br/>

### 6.1.1 LED
---
最も単純で一般的なGPIO出力の例の1つは、LEDの制御です。
デジタル出力を実証するために、LEDを40ピンヘッダーのGPIOピンの1つに接続できます。この例では、LEDのカソード（短い脚）をAI-GボードのGNDピンに接続し、アノード（長い脚）をGPIO72に直接接続します。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- ブレッドボード (x1)
- LED (x1)
- オス-メス ジャンパーワイヤー (x2)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- LED
    - (+) ピンはAI-Gボードのピン26に接続します。
    - (-) ピンはAI-GボードのGNDとして機能するピン14に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.1.1%20AI-G%20GPIO%20LED%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>図 6.2 AI-G GPIO LED 回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <p><strong>表 6.1 AI-G LEDのピンマッピング</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">LED (+) ピン</td>
      <td>26</td>
      <td>72</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-GボードのGPIO72に接続されたLEDを操作するには、以下のコードを実行します：

```bash
#!/bin/bash

GPIO=72
INTERVAL=1

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "out" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Toggling GPIO$GPIO every $INTERVAL second(s). Press Ctrl+C to stop."

while true; do
    echo 1 > /sys/class/gpio/gpio$GPIO/value
    sleep $INTERVAL
    echo 0 > /sys/class/gpio/gpio$GPIO/value
    sleep $INTERVAL
done
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_GPIO_LED_TEST
```

このスクリプトは、GPIO72をデジタル出力として構成し、1秒ごとにその状態を継続的に切り替えます。実行すると、GPIO72に接続されたLEDが繰り返し点滅し、1秒間点灯してから1秒間消灯する無限ループになります。

スクリプトを停止するには、**[Ctrl+C]**を押します。
スクリプトが終了すると、GPIO72は自動的にエクスポート解除され、クリーンアップされます。
実行する前に、スクリプトに実行権限を与えてください：
```bash
$ chmod +x AI_GPIO_LED_TEST
```

**注**: このセットアップには電流制限抵抗が含まれていません。短期間のテストでは機能する可能性がありますが、GPIOピンへの潜在的な損傷を避けるために、LEDと直列に抵抗を使用することをお勧めします。

<br/><br/><br/><br/>

### 6.1.2 ボタン
---
プッシュボタンは、GPIOを介したデジタル入力処理を実証するために一般的に使用される基本的な入力デバイスです。
この例では、ボタンの片側をAI-Gボードの3.3V電源ピンに接続し、もう片側をGPIO79に接続します。ボタンが押されると、GPIO79は1のHigh信号を読み取ります。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- ブレッドボード (x1)
- ボタン (x1)
- オス-メス ジャンパーワイヤー (x2)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- ボタンスイッチ
    - ボタンスイッチの片方の脚はAI-Gボードのピン22に接続します。
    - ボタンの上の反対側の脚は3.3Vピンに接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.1.2%20AI-G%20GPIO%20Button%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>図 6.3 AI-G GPIO ボタン回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>表 6.2 AI-G ボタンのピンマッピング</strong></p>
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">ボタンの片方の脚のピン</td>
      <td>22</td>
      <td>79</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-GボードのGPIO79に接続されたボタン入力を監視するには、以下のコードを実行します：

```bash
#!/bin/bash

GPIO=79

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "in" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Monitoring GPIO$GPIO for button press..."
echo "Press Ctrl+C to stop."

PREV_VALUE=0

while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Button pressed (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_GPIO_BUTTON_TEST
```

このスクリプトは、GPIO79をデジタル入力として構成し、その値をリアルタイムで継続的に監視します。
実行すると、GPIO79に接続されたボタンを押すと、ボタンが押されたことを示すメッセージが表示されます。

スクリプトを停止するには、**[Ctrl+C]**を押します。
スクリプトが終了すると、GPIO79は自動的にエクスポート解除され、クリーンアップされます。
実行する前に、スクリプトに実行権限を与えてください：
```bash
$ chmod +x AI_GPIO_BUTTON_TEST
```

**注:** ここでは例としてGPIO72とGPIO79を使用しています。40ピンヘッダーのピンマップに基づいて、AI-G上の利用可能な任意のGPIOピンを使用できます。公式のピン配置図を参照して、ハードウェア構成に適したGPIO番号を選択してください。

<br/><br/><br/><br/>


### 6.1.3 タッチセンサー
---
タッチセンサーは、物理的な接触を検出し、タッチされたときにHigh信号を出力するデジタル入力デバイスです。
この例では、タッチセンサーがAI-Gボードに接続され、その出力はGPIO88を介して監視されます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- タッチセンサー (x1)
- メス-メス ジャンパーワイヤー (x3)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- タッチセンサー
    - タッチセンサーのVCCピンはAI-Gボードの3.3Vピンに接続します。
    - タッチセンサーのGNDピンはAI-GボードのGNDに接続します。
    - タッチセンサーのSIGピンはAI-Gボードのピン8 (GPIO88) に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/touch.png" width="600"></p>
<p align="center"><strong>図 6.4 AI-G GPIO タッチセンサー回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>表 6.3 AI-G タッチセンサーのピンマッピング</strong></p>
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>1</td>
      <td>3.3V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>14</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">SIG</td>
      <td>8</td>
      <td>88</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-GボードのGPIO88に接続されたタッチセンサー入力を監視するには、以下のコードを実行します：

```bash
#!/bin/bash

GPIO=88

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "in" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Monitoring GPIO$GPIO for touch input..."
echo "Press Ctrl+C to stop."

PREV_VALUE=0

while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Touch detected (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_TOUCH_TEST
```

実行すると、このスクリプトはGPIO88でのタッチ入力を検出します。
タッチ面への接触が検出されると、センサーはHigh信号を送信し、コンソールに「Touch detected (value: 1)」というメッセージが表示されます。

スクリプトを停止するには、**[Ctrl+C]**を押します。スクリプトはその後、自動的にGPIO88をエクスポート解除します。

スクリプトを実行する前に、実行権限があることを確認してください：
```bash
$ chmod +x AI_TOUCH_TEST
```

**注**: ここでは例としてGPIO88を使用しています。40ピンヘッダーのピンマップに基づいて、AI-G上の利用可能な任意のGPIOピンを使用できます。競合を避けるために、AI-Gの公式40ピン配置図を参照してください。

<br/><br/><br/><br/>


### 6.1.4 振動検知センサー
---
振動検知センサーは、物理的な振動や衝撃を検出し、振動が感知されたときにHigh信号を出力します。
この例では、センサーがAI-Gボードに接続され、振動入力はデジタルGPIO 89を介して検出されます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- 振動検知センサー (x1)
- メス-メス ジャンパーワイヤー (x3)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- 振動検知センサー
    - 振動検知センサーのVCCピンはAI-Gボードの5Vピンに接続します。
    - 振動検知センサーのGNDピンはAI-GボードのGNDに接続します。
    - 振動検知センサーのデジタル出力 (DO) ピンはAI-Gボードのピン10 (GPIO89) に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/vibe.png" width="600"></p>
<p align="center"><strong>図 6.5 AI-G GPIO 振動検知センサー回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>表 6.4 AI-G 振動検知センサーのピンマッピング</strong></p>
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>2</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>20</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">DO</td>
      <td>10</td>
      <td>89</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-GボードのGPIO89に接続された振動検知センサー入力を監視するには、以下のコードを実行します：

```bash
#!/bin/bash

GPIO=89

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "in" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Monitoring GPIO$GPIO for vibration..."
echo "Press Ctrl+C to stop."

PREV_VALUE=1

while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Vibration detected (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_VIBRATION_TEST
```

実行すると、このスクリプトはGPIO89での振動入力を検出します。
センサーが振動や衝撃を検出すると、High信号を送信し、コンソールに「Vibration detected (value: 1)」というメッセージが表示されます。

スクリプトを停止するには、**[Ctrl+C]**を押します。スクリプトはその後、自動的にGPIO89をエクスポート解除します。

スクリプトを実行する前に、実行権限があることを確認してください：
```bash
$ chmod +x AI_VIBRATION_TEST
```

**注**: ここでは例としてGPIO89を使用しています。40ピンヘッダーのピンマップに基づいて、AI-G上の利用可能な任意のGPIOピンを使用できます。競合を避けるために、AI-Gの公式40ピン配置図を参照してください。

<br/><br/><br/><br/>


### 6.1.5 赤外線センサー (SZH-SSBH-002)
---
赤外線センサーは、反射された赤外線を放射および受信することによって近くの障害物を検出し、物体が検出されたときにHigh信号を出力します。
この例では、SZH-SSBH-002赤外線センサーがAI-Gボードに接続され、障害物検出はデジタルGPIO 88を介して監視されます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- 赤外線センサー (SZH-SSBH-002) (x1)
- メス-メス ジャンパーワイヤー (x3)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- 赤外線センサー
    - 赤外線センサーのVCCピンはAI-Gボードの3.3Vピンに接続します。
    - 赤外線センサーのGNDピンはAI-GボードのGNDに接続します。
    - 赤外線センサーのOUTピンはAI-Gボードのピン8 (GPIO88) に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ir.png" width="600"></p>
<p align="center"><strong>図 6.6 AI-G GPIO 赤外線センサー回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>表 6.5 AI-G 赤外線センサーのピンマッピング</strong></p>
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>1</td>
      <td>3.3V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>14</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">OUT</td>
      <td>8</td>
      <td>88</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-GボードのGPIO88に接続された赤外線センサー入力を監視するには、以下のコードを実行します：

```bash
#!/bin/bash

GPIO=88

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "in" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Monitoring GPIO$GPIO for obstacle detection..."
echo "Press Ctrl+C to stop."

PREV_VALUE=1

while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Obstacle detected (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_GPIO_IR_TEST
```

実行すると、このスクリプトはGPIO88での障害物入力を検出します。
センサーが近くの物体を検出すると、High信号を送信し、コンソールに「Obstacle detected (value: 1)」というメッセージが表示されます。

スクリプトを停止するには、**[Ctrl+C]**を押します。スクリプトはその後、自動的にGPIO88をエクスポート解除します。

スクリプトを実行する前に、実行権限があることを確認してください：
```bash
$ chmod +x AI_GPIO_IR_TEST
```

**注**: ここでは例としてGPIO88を使用しています。40ピンヘッダーのピンマップに基づいて、AI-G上の利用可能な任意のGPIOピンを使用できます。競合を避けるために、AI-Gの公式40ピン配置図を参照してください。

<br/><br/><br/><br/>


### 6.1.6 大気汚染検知センサー (デジタル出力)
---
大気汚染検知センサー（例：MQシリーズ）は、LPG、メタン、CO、煙などの可燃性ガスや有毒ガスの存在を検出します。
ガス濃度が特定のしきい値を超えると、センサーはデジタル出力 (DO) ピンを介してHigh信号を出力します。
この例では、センサーがAI-Gボードに接続され、ガスの存在はGPIO88を介して検出されます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- 大気汚染検知センサーモジュール (x1)
- メス-メス ジャンパーワイヤー (x3)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- 大気汚染検知センサー
    - 大気汚染検知センサーのVCCピンはAI-Gボードの5Vピンに接続します。
    - 大気汚染検知センサーのGNDピンはAI-GボードのGNDに接続します。
    - 大気汚染検知センサーのデジタル出力 (DO) ピンはAI-Gボードのピン8 (GPIO88) に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/air.png" width="600"></p>
<p align="center"><strong>図 6.7 AI-G GPIO 大気汚染検知センサー回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>表 6.6 AI-G 大気汚染検知センサーのピンマッピング</strong></p>
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>1</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>14</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">SIG</td>
      <td>8</td>
      <td>88</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-GボードのGPIO88に接続された大気汚染検知センサー入力を監視するには、以下のコードを実行します：

```bash
#!/bin/bash

GPIO=88

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "in" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Monitoring GPIO$GPIO for gas detection..."
echo "Press Ctrl+C to stop."

PREV_VALUE=1

while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Gas detected! (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_GPIO_GAS_TEST
```

実行すると、このスクリプトはGPIO88でのガス検出を監視します。
ガス濃度がしきい値を超えると、センサーはHigh信号を送信し、コンソールに「Gas detected! (value: 1)」というメッセージが表示されます。

スクリプトを停止するには、**[Ctrl+C]**を押します。スクリプトはその後、自動的にGPIO88をエクスポート解除します。

スクリプトを実行する前に、実行権限があることを確認してください：
```bash
$ chmod +x AI_GPIO_GAS_TEST
```

**注**: ここでは例としてGPIO88を使用しています。40ピンヘッダーのピンマップに基づいて、AI-G上の利用可能な任意のGPIOピンを使用できます。競合を避けるために、AI-Gの公式40ピン配置図を参照してください。

<br/><br/><br/><br/>


## 6.2 I2C
---
AI-Gは、40ピンGPIOヘッダーを介してI2C通信を提供し、センサー、ディスプレイ、拡張モジュールなどのさまざまな周辺機器とのインターフェースを可能にします。Inter-Integrated Circuit (I2C) は、データライン (SDA) とクロックライン (SCL) で構成される2線式通信プロトコルであり、共有バス上で複数のデバイスが通信できるようにします。

I2C通信はマスター・スレーブアーキテクチャに従い、1つのマスターデバイスが通信を制御し、最大127のスレーブデバイスを同じバスに接続できます。SDAラインはデータの送受信の両方に使用され、SCLラインはデータ転送のタイミングを同期します。この同期通信モデルにより、デバイスは調整されたクロック駆動の方法で情報を交換できます。
<br/><br/><br/>

### 6.2.1 1602A LCD ディスプレイ
---
1602A LCDは、組み込みシステムで一般的に使用されるキャラクターディスプレイモジュールです。AI-Gでは、LCDのSDAおよびSCLラインをI2C用に構成されたGPIOピンに接続できます。接続すると、Linux I2Cツールまたはカスタムソフトウェアを使用してLCDを制御できます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- 1602A LCD ディスプレイ (x1)
- メス-メス ジャンパーワイヤー (x4)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- LCD1602A
    - LCD1602AのVCCピンはAI-Gボードの5Vピンに接続します。
    - LCD1602AのGNDピンはAI-GボードのGNDに接続します。
    - LCD1602AのSDAピンはAI-Gボードのピン3に接続します。
    - LCD1602AのSCLピンはAI-Gボードのピン5に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.2.1%20AI-G%20I2C%20LCD Display%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>図 6.8 AI-G I2C LCD ディスプレイ回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <p><strong>表 6.7 AI-G LCD ディスプレイのピンマッピング</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>6</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>4</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">SDA</td>
      <td>3</td>
      <td>103</td>
    </tr>
    <tr>
      <td colspan="3">SCL</td>
      <td>5</td>
      <td>102</td>
    </tr>
  </table>
</div>
<br/>

#### ステップ 3. 実行方法
AI-Gボード上のI2Cデバイスにアクセスするには、i2c-devインターフェースを使用してCプログラムを作成し、ターゲットアーキテクチャ用にクロスコンパイルする必要があります。
以下は簡単な例 (I2C_TEST.c) です：

```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <unistd.h>

#define I2C_DEV "/dev/i2c-1"
#define I2C_ADDR 0x27

// RS: 0 = command, 1 = data
void lcd_send_byte(int fd, unsigned char data, unsigned char mode) {
    unsigned char high = mode | (data & 0xF0) | 0x08; // backlight on
    unsigned char low  = mode | ((data << 4) & 0xF0) | 0x08;
    unsigned char buf[4] = { high | 0x04, high, low | 0x04, low }; // toggle EN bit

    for (int i = 0; i < 4; i++) {
        if (write(fd, &buf[i], 1) != 1) {
            perror("I2C write error");
        }
        usleep(1000); // 1ms delay
    }
}

void lcd_command(int fd, unsigned char cmd) {
    lcd_send_byte(fd, cmd, 0x00);
}

void lcd_data(int fd, unsigned char data) {
    lcd_send_byte(fd, data, 0x01);
}

void lcd_init(int fd) {
    usleep(50000); // wait for LCD power on
    lcd_command(fd, 0x33); // init
    lcd_command(fd, 0x32); // 4-bit mode
    lcd_command(fd, 0x28); // 2 line, 5x8 font
    lcd_command(fd, 0x0C); // display on, cursor off
    lcd_command(fd, 0x06); // entry mode
    lcd_command(fd, 0x01); // clear display
    usleep(2000);
}

void lcd_print(int fd, const char* str) {
    while (*str) {
        lcd_data(fd, *str++);
    }
}

int main() {
    int fd = open(I2C_DEV, O_RDWR);
    if (fd < 0) {
        perror("Failed to open I2C device");
        return 1;
    }

    if (ioctl(fd, I2C_SLAVE, I2C_ADDR) < 0) {
        perror("Failed to set I2C address");
        close(fd);
        return 1;
    }

    lcd_init(fd);
    lcd_print(fd, "test pass!");

    close(fd);
    return 0;
}
```

##### ステップ 3.1 ツールチェーンのインストール (gcc-arm-9.2)
ARM 64ビット (AArch64) アーキテクチャ用のバイナリをビルドするには、特に組み込みLinux環境では、クロスコンパイルツールチェーンが必要です。
このステップでは、AArch64用のGCC ARM 9.2ツールチェーンをインストールします。

```
$ wget https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz

$ tar -xvf gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz

$ echo "export PATH=~/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin:\$PATH" >> ~/.bashrc
$ source ~/.bashrc

$ aarch64-none-linux-gnu-gcc --version
aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10)) 9.2.1 20191025
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

##### ステップ 3.2 AArch64用のI2C_TEST.cソースファイルのクロスコンパイル
AI-G用のクロスコンパイルツールチェーンを準備し、以下のコマンドを使用してプログラムをコンパイルします：

```
$ aarch64-none-linux-gnu-gcc -o I2C_TEST I2C_TEST.c
$ ls
I2C_TEST.c I2C_TEST
```

##### ステップ 3.3 プログラムのAI-Gへの転送と実行
ホストシステムでバイナリをクロスコンパイルした後、以下のコマンドを使用してバイナリをAI-Gに転送します：

```
$ scp I2C_TEST root@192.168.0.100:/home/root/
```

AI-G上で、以下のコマンドを使用してプログラムを実行します：
```
$ chmod +x I2C_TEST
$ ./I2C_TEST
```

#### ステップ 4. 実行結果
このプログラムは、1602A I2C LCDディスプレイを初期化し、AI-Gボード上のI2Cインターフェースを介してテストメッセージを表示します。実行すると、LCD画面に「test pass!」というメッセージが表示されます。
メッセージが表示されない場合は、以下を確認してください：
- SDAおよびSCLピンが正しく接続されていることを確認します。
- I2CデバイスアドレスがLCDモジュールと一致していることを確認します。
- 電源 (5V, GND) が適切に供給されていることを確認します。
<br/><br/><br/><br/>


## 6.3 SPI
---
AI-Gは、40ピンGPIOヘッダーを介してSerial Peripheral Interface (SPI) 通信をサポートしており、外部デバイスとボード間のデータ交換を可能にします。

SPIは、全二重通信を可能にする同期シリアル通信プロトコルであり、データの送受信を同時に行うことができます。主に4つのラインを使用します：Master Out Slave In (MOSI)、Master In Slave Out (MISO)、Serial Clock (SCLK)、およびSlave Select (SS)。

複数のデバイスで共有ラインを使用するI2Cとは異なり、SPIは各スレーブデバイスに専用のSSラインを必要とします。この1対多の構造により、SPIは高速で実装が簡単ですが、複数のデバイスが関与する場合、より多くの物理的な配線が必要になる場合があります。
<br/><br/><br/>

### 6.3.1 ドットマトリックス
---
8x8ドットマトリックスディスプレイは、組み込みシステムでの単純なテキストまたはパターン出力によく使用されます。AI-Gでは、MAX7219などのドライバチップを使用してSPI経由でドットマトリックスモジュールを制御できます。

MAX7219は行と列のスキャンを内部で処理するため、マイクロコントローラーはMOSI (DIN)、SCLK、CS (LOAD) のわずか数本のSPI信号を使用してディスプレイ全体を制御できます。接続すると、ユーザー定義のスクリプトまたはライブラリを介してSPI通信を使用してディスプレイを制御できます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- 8x8 ドットマトリックス
- メス-メス ジャンパーワイヤー (x5)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
- 8x8 ドットマトリックス
    - 8x8ドットマトリックスのVCCピンはAI-Gボードの5Vピンに接続します。
    - 8x8ドットマトリックスのGNDピンはAI-GボードのGNDに接続します。
    - 8x8ドットマトリックスのDINピンはAI-Gボードのピン19に接続します。
    - 8x8ドットマトリックスのCSピンはAI-Gボードのピン24に接続します。
    - 8x8ドットマトリックスのCLKピンはAI-Gボードのピン23に接続します。

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.3.1%20AI-G%20SPI%20Dot Matrix%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>図 6.9 AI-G SPI ドットマトリックス回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <p><strong>表 6.8 AI-G ドットマトリックスのピンマッピング</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="3">ピン名</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>2</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>6</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">DIN</td>
      <td>19</td>
      <td>94</td>
    </tr>
    <tr>
      <td colspan="3">CS</td>
      <td>24</td>
      <td>93</td>
    </tr>
    <tr>
      <td colspan="3">CLK</td>
      <td>23</td>
      <td>92</td>
    </tr>
  </table>
</div><br/>

#### ステップ 3. 実行方法
AI-G上のSPIデバイスと通信するには、spidevインターフェースを使用してCプログラムを作成し、ターゲットアーキテクチャ用にクロスコンパイルする必要があります。
以下は、MAX7219 LEDマトリックスディスプレイにデータを送信する簡単な例 (SPI_TEST.c) です：

```
#include <stdio.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/spi/spidev.h>
#include <sys/ioctl.h>
#include <string.h>

#define SPI_DEV "/dev/spidev3.0"

int spi_fd = -1;

void spi_send(uint8_t address, uint8_t data) {
    uint8_t tx[2] = { address, data };
    struct spi_ioc_transfer tr = {
        .tx_buf = (uintptr_t)tx,
        .rx_buf = 0,
        .len = 2,
        .delay_usecs = 0,
        .speed_hz = 1000000,
        .bits_per_word = 8,
    };

    if (ioctl(spi_fd, SPI_IOC_MESSAGE(1), &tr) < 1) {
        perror("SPI send failed");
    }
}

void max7219_init() {
    spi_send(0x09, 0x00); // Decode mode off
    spi_send(0x0A, 0x08); // Brightness (0x00 ~ 0x0F)
    spi_send(0x0B, 0x07); // Scan limit: display all 8 digits
    spi_send(0x0C, 0x01); // Shutdown register: normal operation
    spi_send(0x0F, 0x00); // Display test: off
}

void max7219_clear() {
    for (int i = 1; i <= 8; i++) {
        spi_send(i, 0x00);
    }
}


const uint8_t letter_P[8] = {
    0b00000000,  
    0b01111110, 
    0b01000010,  
    0b01000010,  
    0b01111110,  
    0b01000000,  
    0b01000000,  
    0b01000000   
};


void draw_letter_P() {
    for (int row = 0; row < 8; row++) {
        spi_send(row + 1, letter_P[row]);
    }
}

int main() {
    spi_fd = open(SPI_DEV, O_RDWR);
    if (spi_fd < 0) {
        perror("Failed to open SPI device");
        return 1;
    }

    max7219_init();
    max7219_clear();
    draw_letter_P();

    close(spi_fd);
    return 0;
}
```

##### ステップ 3.1 ツールチェーンのインストール (gcc-arm-9.2)
ARM 64ビット (AArch64) アーキテクチャ用のバイナリをビルドするには、特に組み込みLinux環境では、クロスコンパイルツールチェーンが必要です。
このステップでは、AArch64用のGCC ARM 9.2ツールチェーンをインストールします。
```
$ wget https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz

$ tar -xvf gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz

$ echo "export PATH=~/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin:\$PATH" >> ~/.bashrc
$ source ~/.bashrc

$ aarch64-none-linux-gnu-gcc --version
aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10)) 9.2.1 20191025
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

##### ステップ 3.2 AArch64用のSPI_TEST.cソースファイルのクロスコンパイル
AI-G用のクロスコンパイルツールチェーンを準備し、以下のコマンドを使用してプログラムをコンパイルします：

```
$ aarch64-none-linux-gnu-gcc -o SPI_TEST SPI_TEST.c
$ ls
SPI_TEST.c SPI_TEST
```

##### ステップ 3.3 プログラムのAI-Gへの転送と実行
ホストシステムでバイナリをクロスコンパイルした後、以下のコマンドを使用してバイナリをAI-Gに転送します：

```
$ scp SPI_TEST root@192.168.0.100:/home/root/
```

AI-G上で、以下のコマンドを使用してプログラムを実行します：
```
$ chmod +x SPI_TEST
$ ./SPI_TEST
```

#### ステップ 4. 実行結果
このプログラムは、MAX7219 LEDドットマトリックスディスプレイを初期化し、SPIインターフェースを介してデータを送信し、ディスプレイに文字 **P** をレンダリングします。実行すると、8x8 LEDマトリックスは事前定義されたビットパターンに基づいて文字 **P** を表示するはずです。
何も表示されない場合やパターンが歪んでいる場合は、以下を確認してください：
- SPIピン (MOSI, SCK, CS) の配線が正しいことを確認します。
- MAX7219モジュールに適切に電力が供給されており (5V, GND)、すべてのデータ/クロックラインが安定していることを確認します。
<br/><br/><br/><br/>


## 6.4 UART
---
AI-Gは、40ピンGPIOヘッダーを介してUniversal Asynchronous Receiver/Transmitter (UART) 通信をサポートしており、シリアルコンソールや他のマイクロコントローラーなどのデバイスとのシリアル通信を可能にします。

UARTは、TX（送信）とRX（受信）の2本のラインを介して一度に1ビットのデータを送信する、広く使用されている非同期通信プロトコルです。クロックラインを使用するI2CやSPIとは異なり、UARTはクロックラインを使用しません。代わりに、2つのデバイスはタイミングのために共通の通信速度を使用する必要があります。
<br/><br/><br/>

### 6.4.1 UART ループバックテスト
---
UARTループバックテストは、AI-G上でUART通信が正しく機能していることを確認する簡単な方法です。
TXピンとRXピンを接続することで、ボードから送信されたデータはすぐに受信されます。
このテストは、Linuxターミナルを使用してUARTデバイスにデータを書き込み、それを読み戻すことで実行できます。

#### ステップ 1. ハードウェア要件
- AI-Gボード (x1)
- メス-メス ジャンパーワイヤー (x1)
- DC 5V 電源アダプター (x1)
- USB - TTL シリアルケーブル (x1)

#### ステップ 2. 回路例
**配線:** TX <-> RX を接続

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.4.1%20AI-G%20UART%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>図 6.10 AI-G UART 回路図  </strong></p><br/>

##### ステップ 2.1 ピンマッピング
以下の表はピンマッピングを示しています。

<div style="text-align: center;">
  <p><strong>表 6.9 AI-G UARTのピンマッピング</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="2">ピン名</th>
      <th>AI-G</th>
    </tr>
    <tr>
      <td colspan="2">TX</td>
      <td>10</td>
    </tr>
    <tr>
      <td colspan="2">RX</td>
      <td>8</td>
    </tr>
  </table>
</div><br/>

#### ステップ 3. 実行方法
このスクリプトは、UARTポートにテストメッセージを送信し、同じメッセージが受信されるかどうかを確認します。
AI-GでUARTループバックをテストするには、TXピンとRXピンを接続した後に以下のスクリプトを実行します。

```bash
#!/bin/bash
# ===================== user setting =====================
UART_DEV="/dev/ttyAMA1"       # uart
BAUD=115200                   # Baudrate
TEST_MSG="Hello from UART"    # msg
TEMP_FILE="/tmp/uart_rx.txt"  # file
# =====================================================

if [ ! -e "$UART_DEV" ]; then
    echo "Error: $UART_DEV does not exist"
    exit 1
fi

chmod 666 $UART_DEV

stty -F $UART_DEV $BAUD cs8 -cstopb -parenb -icanon -echo -ixon -ixoff
echo "UART setup complete: port=$UART_DEV, speed=$BAUD"

cat $UART_DEV > $TEMP_FILE &
RX_PID=$!

sleep 0.2
echo -n "$TEST_MSG" > $UART_DEV
echo "Transmission complete: \"$TEST_MSG\""

sleep 1
kill $RX_PID 2>/dev/null

if [ -f "$TEMP_FILE" ]; then
    RECEIVED=$(cat $TEMP_FILE)
    rm $TEMP_FILE
    if [ "$RECEIVED" = "$TEST_MSG" ]; then
        echo "Loopback Success! Received Message: \"$RECEIVED\""
    else
        echo "Received mismatch"
        echo "Sent: \"$TEST_MSG\""
        echo "Received: \"$RECEIVED\""
    fi
else
    echo "Failed to receive: No received file"
fi
```

#### ステップ 4. 実行結果
以下のコマンドでコードを実行します。
```
$ ./AI_UART_LOOPBACK_TEST
```

このスクリプトは、指定されたUARTポートを構成し、テストメッセージを送信します。TXピンとRXピンが正しく接続されている場合、同じメッセージが受信されてターミナルに出力され、UARTの送受信が適切に機能していることが確認されます。

実行する前に、スクリプトに実行権限を与えてください：
```bash
$ chmod +x AI_UART_LOOPBACK_TEST
```
<br/><br/><br/><br/>
