# 1. 소개 
---
이 문서는 AI-G 사용 예제를 제공합니다.   
이 문서는 다음 정보를 포함합니다:
- 비디오 출력
  - MIPI DSI
- 카메라 연결
  - MIPI CSI
- 스토리지 연결
  - NVMe M.2 SSD
- 이더넷 연결
- 40-pin GPIO 헤더
  - 사용 가능한 센서 및 장치
<br/><br/><br/><br/>


# 2. 비디오 출력
---
AI-G는 MIPI DSI-2 인터페이스를 통해 비디오 출력을 지원합니다.
15-pin FFC 커넥터를 통해 2-lane DSI 연결을 제공하며, 호환되는 MIPI DSI LCD 패널을 연결하는 데 적합합니다. 이 인터페이스는 임베디드 디스플레이에서 그래픽 사용자 인터페이스, 비디오 재생 및 실시간 AI 시각화를 부드럽게 렌더링할 수 있게 해줍니다.
<br/><br/><br/>

## 2.1 MIPI DSI
---
DSI는 Display Serial Interface의 약자로, 프로세서에서 외부 화면으로 디스플레이 데이터를 전송하기 위해 MIPI Alliance에서 정의한 표준입니다. 임베디드 LCD 패널에 적합한 고속, 저전력 통신을 가능하게 합니다.  
위에서 언급했듯이 AI-G는 15-pin FFC 커넥터를 통해 2-lane DSI 연결을 제공하여 GUI 렌더링, 비디오 재생 또는 실시간 추론 시각화를 위해 호환되는 MIPI DSI 디스플레이 모듈을 연결할 수 있습니다.
<br/><br/>

### 2.1.1 5인치 DSI 디스플레이
Elecrow 5인치 DSI 디스플레이는 IPS 패널과 정전식 터치 지원을 갖춘 800×480 해상도 LCD로, 라즈베리 파이의 MIPI DSI 인터페이스와 함께 사용하도록 설계되었습니다. 플러그 앤 플레이 기능 덕분에 별도의 드라이버 설치가 필요하지 않습니다. 디스플레이는 15-pin MIPI DSI 커넥터를 통해 AI-G 보드에 연결되며 인터페이스를 통해 직접 전원을 공급받으므로 외부 전원 공급 장치가 필요하지 않습니다.  
이 모듈은 AI-G 플랫폼에서 GUI 기반 애플리케이션, 실시간 모니터링 및 대화형 AI 데모에 적합합니다.

DSI 디스플레이의 사양은 다음과 같습니다:

| 사양                | 설명                                       |
| ------------------- | -------------------------------------------|
| 디스플레이 크기     | 5 인치                                     |
| 해상도              | 800 x 480                                  |
| 주사율              | 60 Hz                                      |
| 인터페이스 (디스플레이) | MIPI DSI                                   |
| 인터페이스 (패널)   | RGB888 포트                                |
| 작동 전압           | 3.3V                                      |
| 작동 온도 범위      | -20 °C ~ 70 °C                            |
| 케이블 유형         | Flat Flexible Cable (FFC) (15-pin)                               |
| 호환성              | 라즈베리 파이 및 AI-G (MIPI DSI 인터페이스를 통해)|

다음 단계에 따라 DSI 디스플레이를 테스트할 수 있습니다:

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%205.%20display.png" width="400"></p>
<p align="center"><strong>그림 2.1 5인치 DSI 디스플레이 </strong></p><br/>

#### 단계 1. 디스플레이를 AI-G 보드 MIPI DSI에 연결
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%206.%20Connecting%20Display%20to%20AI-G.png" width="500"></p>
<p align="center"><strong>그림 2.2 디스플레이를 AI-G 보드에 연결 </strong></p><br/>

#### 단계 2. AI-G 보드에서 MIPI DSI 연결 확인
디스플레이가 AI-G 보드에 제대로 연결되었는지 확인하려면 다음 명령을 입력하고 확인하십시오.  
```
$ dmesg | grep -i display
```

**참고**: 디스플레이를 연결하고 보드의 전원을 켜십시오. 보드가 이미 켜져 있는 경우 디스플레이를 연결한 후 보드를 재부팅하십시오.
<br/><br/><br/><br/>


# 3. 카메라 연결
---
AI-G는 MIPI CSI-2 인터페이스를 통해 카메라 입력을 지원합니다.
기본적으로 15-pin 커넥터를 통해 2-lane CSI 연결을 제공합니다. 고해상도 또는 높은 프레임 속도의 AI 비전 작업과 같이 더 높은 대역폭이 필요한 애플리케이션의 경우 옵션인 20-pin 커넥터를 통해 4-lane 구성도 지원됩니다.
<br/><br/><br/>

## 3.1 MIPI CSI
---
CSI는 Camera Serial Interface의 약자로, 카메라 모듈을 호스트 프로세서에 연결하기 위해 MIPI Alliance에서 정의한 표준 인터페이스입니다. 카메라에서 프로세서로 이미지 데이터를 고속, 저전력으로 전송할 수 있습니다.  
위에서 설명한 대로 AI-G는 기본적으로 2-lane CSI 연결을 제공하며, 더 높은 데이터 처리량을 위해 20-pin 커넥터를 통한 4-lane 구성을 옵션으로 지원합니다.  

현재 AI-G는 ArduCam (5 MP) 및 Raspberry Pi v1 카메라 (5 MP) 모듈만 지원합니다.
<br/><br/>

### 3.1.1 ArduCam
ArduCam은 임베디드 시스템 및 AI 애플리케이션을 위해 설계된 다목적 카메라 모듈입니다. MIPI CSI를 포함한 다양한 이미지 센서 및 인터페이스를 지원하여 AI-G와 같은 개발 보드와 통합하기에 적합합니다.  
AI-G는 2-lane 또는 4-lane MIPI CSI 인터페이스가 있는 ArduCam 모듈을 지원하여 객체 감지 및 이미지 분류와 같은 AI 비전 작업을 위한 안정적인 이미지 입력을 가능하게 합니다. FFC 케이블과의 호환성 덕분에 ArduCam 모듈은 AI-G 보드의 CSI 커넥터에 쉽게 연결할 수 있어 엣지 AI 시스템에서 실시간 카메라 입력을 위한 신뢰할 수 있는 솔루션을 제공합니다.

ArduCam 모듈의 사양은 다음과 같습니다:

| 사양                     | 설명                                        |
| ------------------------ | ------------------------------------------- |
| 센서                     | OV5647 (5 Megapixel)                        |
| 해상도                   | 2592 × 1944 (Full 5MP)                      |
| 지원되는 출력 형식       | RAW, YUV, JPEG (센서에 따라 다름)           |
| 인터페이스               | MIPI CSI                                    |
| 프레임 속도              | 1080p에서 최대 30fps, 720p에서 60fps        |
| 렌즈 마운트              | 고정 초점 렌즈 (표준)                       |
| 시야각 (FOV)             | 약 54° ~ 70° (모델에 따라 다름)             |
| 연결 유형                | FFC                   |
| 작동 전압                | 3.3V (일반)                                 |
| 폼 팩터                  | 소형 PCB, 약 25 mm x 24 mm                   |
| 호환성                   | 라즈베리 파이 및 AI-G (MIPI CSI 포트를 통해)      |
| 추가 기능                | 저전력 소비, 플러그 앤 플레이 모듈          |

다음 단계에 따라 ArduCam을 테스트할 수 있습니다:

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%201.%20arducam.png" width="400"></p>
<p align="center"><strong>그림 3.1 ArduCam </strong></p><br/>

#### 단계 1. ArduCam을 AI-G 보드 MIPI CSI에 연결
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%202.%20Connecting%20Cam%20to%20AI-G.png" width="500"></p>
<p align="center"><strong>그림 3.2 ArduCam을 AI-G 보드에 연결 </strong></p><br/>

#### 단계 2. AI-G 보드에서 MIPI CSI 연결 확인
ArduCam이 AI-G 보드에 제대로 연결되었는지 확인하려면 다음 명령을 입력하고 확인하십시오.  
```
$ dmesg | grep -i "ov5647"
```

**참고**: 카메라를 연결하고 보드의 전원을 켜십시오. 보드가 이미 켜져 있는 경우 카메라를 연결한 후 보드를 재부팅하십시오.
<br/><br/>


### 3.1.2 Raspberry Pi v1 카메라
Raspberry Pi 카메라 모듈 v1은 Raspberry Pi Foundation에서 개발한 소형 5 MP 카메라입니다. OmniVision OV5647 이미지 센서를 기반으로 하며 FFC(Flat Flexible Cable)를 사용하여 MIPI CSI-2 인터페이스를 통해 호스트 보드에 연결됩니다. 

원래 라즈베리 파이 시리즈용으로 설계된 이 모듈은 15-pin MIPI CSI 커넥터를 통해 AI-G와도 호환됩니다. AI-G 플랫폼에서 이미지 캡처, 비디오 스트리밍 및 AI 기반 컴퓨터 비전 작업과 같은 엔트리 레벨 카메라 애플리케이션을 위한 신뢰할 수 있는 솔루션을 제공합니다.

Raspberry Pi v1 카메라 모듈의 사양은 다음과 같습니다:

| 사양                | 설명                                     |
| ------------------- | ---------------------------------------- |
| 센서                | OmniVision OV5647                        |
| 해상도              | 2592 × 1944 (5 MP)                        |
| 출력 형식           | RAW, YUV, JPEG                           |
| 인터페이스          | MIPI CSI                                 |
| 프레임 속도         | 1080p30, 720p60, VGA90                   |
| 렌즈                | 고정 초점                                |
| 시야각 (FOV)        | 최대 54°                                     |
| 케이블 유형         | FFC (15-pin)                             |
| 보드 치수           | 25 mm x 24 mm                              |
| 호환성              | 라즈베리 파이 및 AI-G (MIPI CSI 포트를 통해)   |

다음 단계에 따라 Raspberry Pi v1 카메라를 테스트할 수 있습니다:

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%203.%20raspv1cam.png" width="400"></p>
<p align="center"><strong>그림 3.3 Raspberry Pi v1 카메라 </strong></p><br/>

#### 단계 1. Raspberry Pi v1 카메라를 AI-G 보드 MIPI CSI에 연결
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/Figure%202.%20Connecting%20Cam%20to%20AI-G.png" width="500"></p>
<p align="center"><strong>그림 3.4 Raspberry Pi v1 카메라를 AI-G 보드에 연결 </strong></p><br/>

#### 단계 2. AI-G 보드에서 MIPI CSI 연결 확인
Raspberry Pi 카메라가 AI-G 보드에 제대로 연결되었는지 확인하려면 다음 명령을 입력하고 확인하십시오.  
```
$ dmesg | grep -i "ov5647"
```

**참고**: 카메라를 연결하고 보드의 전원을 켜십시오. 보드가 이미 켜져 있는 경우 카메라를 연결한 후 보드를 재부팅하십시오.
<br/><br/><br/><br/>


# 4. 스토리지 연결
---
이 장에서는 AI-G 보드를 다양한 스토리지 장치에 연결하는 방법을 다룹니다. 지원되는 스토리지 옵션에는 PCIe를 통한 외부 스토리지가 포함됩니다.
<br/><br/><br/>

## 4.1 NVMe M.2 SSD
---
AI-G는 PCIe 슬롯을 통해 M.2 SSD 스토리지 장치를 지원합니다.

#### 단계 1. SSD 연결
- NVMe SSD (M.2 PCIe): NVMe M.2 SSD를 AI-G 보드의 PCIe 슬롯에 삽입합니다. 

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/4.2.1%20AI-G%20NVME%20M.2%20SSD%20connection.png" width="600"></p>
<p align="center"><strong>그림 4.1 NVMe M.2 SSD를 AI-G 보드에 연결 </strong></p><br/>

#### 단계 2. AI-G 부팅
**reboot** 명령을 실행한 후 부트 로그를 관찰하여 PCIe 장치가 시스템에서 인식되는지 확인합니다.
**"telechips-pcie: Link up"**과 같은 메시지를 찾으십시오. 이는 PCIe 링크가 성공적으로 설정되었음을 나타냅니다.

```
$ reboot
...
Starting kernel ...

[    1.207844] telechips-pcie 12000000.pcie: invalid resource
[    1.232395] telechips-pcie 12000000.pcie: Link up
[    1.521983] debugfs: Directory '18300000.dma' with parent 'dmaengine' already present!
[    1.531159] debugfs: Directory '18310000.dma' with parent 'dmaengine' already present!
[    1.540282] debugfs: Directory '18320000.dma' with parent 
...
ai-g-topst login: 
```

#### 단계 3. SSD 인식 확인

```
root@ai-g-topst:~# lspci
00:00.0 PCI bridge: Synopsys, Inc. Device 750b (rev 01)
01:00.0 Non-Volatile memory controller: Silicon Motion, Inc. SM2263EN SM2263XT SSD Controller (rev 03)
```

#### 단계 4. SSD 마운트
```
$ fdisk /dev/nvme0n1
Welcome to fdisk (util-linux 2.37.4).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): 
```

fdisk 프롬프트 내에서 다음 키를 순서대로 입력하십시오:

- o — 새로운 빈 DOS 파티션 테이블 생성 (선택 사항, 기존 테이블 지움)

- n — 새 파티션 추가

- p — 기본 파티션 선택

- 1 — 파티션 번호를 1로 설정

- Enter 누름 — 기본 첫 번째 섹터 수락

- Enter 누름 — 기본 마지막 섹터 수락 (전체 디스크 사용)

- w — 파티션 테이블 쓰기 및 종료

```
$ mkfs.ext4 /dev/nvme0n1p1

$ mkdir -p /mnt/nvme

$ mount /dev/nvme0n1p1 /mnt/nvme
```

#### 단계 5. 실행 결과
이 출력은 NVMe SSD 장치(/dev/nvme0n1p1)가 시스템에 의해 성공적으로 감지되어 /mnt/nvme에 마운트되었음을 확인합니다.
```
$ df -h

Filesystem            Size  Used Avail Use% Mounted on
devtmpfs              426M     0  426M   0% /dev
/dev/mmcblk0p4        330M  201M  103M  67% /
tmpfs                 100M     0  100M   0% /dev/shm
tmpfs                 274M  8.6M  265M   4% /run
tmpfs                 4.0M     0  4.0M   0% /sys/fs/cgroup
tmpfs                 684M     0  684M   0% /tmp
tmpfs                 684M   12K  684M   1% /var/volatile
tmpfs                 137M     0  137M   0% /run/user/0
/dev/nvme0n1p1        117G   24K  111G   1% /mnt/nvme
```
<br/><br/><br/><br/>

# 5. 이더넷 연결
---
AI-G는 온보드 RJ45 이더넷 포트를 통해 이더넷 연결을 지원합니다. 이를 통해 보드는 표준 TCP/IP 프로토콜을 사용하여 로컬 네트워크 또는 인터넷과 통신할 수 있습니다. 이더넷은 원격 액세스, 데이터 스트리밍 또는 소프트웨어 업데이트가 필요한 AI 애플리케이션을 배포하는 데 일반적으로 사용됩니다.
<br/><br/><br/>

## 5.1 라우터를 통한 네트워크 연결
---
이 방법은 표준 라우터를 사용하여 AI-G를 로컬 네트워크에 연결합니다. 보드는 DHCP를 통해 자동으로 IP 주소를 얻거나 고정 IP 주소로 구성할 수 있습니다.
<br/><br/>

### 5.1.1 루트 파일 시스템을 읽기/쓰기로 다시 마운트
루트 파일 시스템은 읽기 전용으로 마운트됩니다. 다음 명령을 사용하여 구성 파일을 편집할 수 있도록 쓰기 권한으로 다시 마운트하십시오:

```
$ mount -o remount,rw /
```
<br/><br/>


### 5.1.2 네트워크 구성 파일 생성
1. DHCP를 통한 동적 IP
/etc/systemd/network/20-wired.network 파일을 생성하거나 편집하여 eth0 인터페이스에서 DHCP를 활성화합니다.

```
$ vi /etc/systemd/network/20-wired.network
 
[Match]
Name=eth0
 
[Network]
DHCP=yes
```

이 구성은 systemd-networkd가 eth0 인터페이스에 대해 DHCP를 통해 IP 주소를 자동으로 얻도록 지시합니다.

2. 고정 IP 구성
고정 IP 주소를 할당하려는 경우(예: 직접 PC 연결을 사용하거나 DHCP 서버를 사용할 수 없는 경우) 다음 내용으로 동일한 파일을 편집하십시오:
```
$ vi /etc/systemd/network/20-wired.network

[Match]
Name=eth0

[Network]
Address=192.168.137.2/24
Gateway=192.168.137.1
DNS=8.8.8.8
```

이렇게 하면 IP 주소가 192.168.137.2로 설정되고, 192.168.137.1을 게이트웨이(Windows ICS에서 일반적임)로 사용하며, Google DNS를 구성합니다.
<br/><br/>


### 5.1.3 네트워크 서비스 다시 시작
systemd-networkd 서비스를 다시 시작하여 새 네트워크 구성을 적용합니다:

```
sudo systemctl restart systemd-networkd
```
<br/><br/>


### 5.1.4 네트워크 연결 확인
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet4.png"></p>
<p align="center"><strong>그림 5.1 라우터를 통한 네트워크 연결</strong></p><br/>

Google의 공개 DNS 서버에 핑을 보내 인터넷 연결을 테스트합니다:

```
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=113 time=30.208 ms
64 bytes from 8.8.8.8: seq=1 ttl=113 time=38.143 ms
64 bytes from 8.8.8.8: seq=2 ttl=113 time=30.969 ms
64 bytes from 8.8.8.8: seq=3 ttl=113 time=33.586 ms
 
```
<br/><br/><br/>


## 5.2 호스트 PC와 네트워크 공유
---
Windows 운영 체제에서 제공하는 인터넷 연결 공유(ICS) 기능을 활용하면 라우터를 사용하지 않고도 PC의 인터넷 연결을 AI-G와 공유할 수 있습니다.
<br/><br/>

### 5.2.1 호스트 PC 네트워크 구성
- 제어판 → 네트워크 및 인터넷 → 네트워크 연결 → 이더넷 설정
 
1. 인터넷에 연결된 네트워크 어댑터(예: Wi-Fi)를 찾아 마우스 오른쪽 버튼으로 클릭하고 **속성**을 선택합니다.

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet1.png" width="600"></p>
<p align="center"><strong>그림 5.2 속성 선택</strong></p><br/>
 
2. 공유 탭을 선택합니다.

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet2.png" width="400"></p>
<p align="center"><strong>그림 5.3 공유 탭 선택</strong></p><br/>

3. "다른 네트워크 사용자가 이 컴퓨터의 인터넷 연결을 통해 연결하도록 허용"이라는 상자를 체크합니다.
 
4. 홈 네트워킹 연결 드롭다운 메뉴에서 AI-G 보드가 연결될 이더넷 어댑터(예: "이더넷")를 선택합니다.

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet3.png" width="400"></p>
<p align="center"><strong>그림 5.4 이더넷 어댑터 선택</strong></p><br/>
 
5. **확인**을 클릭하여 설정을 저장합니다.

<br/><br/>

### 5.2.2 루트 파일 시스템을 읽기/쓰기로 다시 마운트
루트 파일 시스템은 읽기 전용으로 마운트됩니다. 다음 명령을 사용하여 구성 파일을 편집할 수 있도록 쓰기 권한으로 다시 마운트하십시오:

```
$ mount -o remount,rw /
```
<br/><br/>

### 5.2.3 네트워크 구성 파일 생성
1. DHCP를 통한 동적 IP
/etc/systemd/network/20-wired.network 파일을 생성하거나 편집하여 eth0 인터페이스에서 DHCP를 활성화합니다.
```
$ vi /etc/systemd/network/20-wired.network
 
[Match]
Name=eth0
 
[Network]
DHCP=yes
```

이 구성은 systemd-networkd가 eth0 인터페이스에 대해 DHCP를 통해 IP 주소를 자동으로 얻도록 지시합니다.

2. 고정 IP 구성
고정 IP 주소를 할당하려는 경우(예: 직접 PC 연결을 사용하거나 DHCP 서버를 사용할 수 없는 경우) 다음 내용으로 동일한 파일을 편집하십시오:
```
$ vi /etc/systemd/network/20-wired.network

[Match]
Name=eth0

[Network]
Address=192.168.137.2/24
Gateway=192.168.137.1
DNS=8.8.8.8
```
이렇게 하면 IP 주소가 192.168.137.2로 설정되고, 192.168.137.1을 게이트웨이(Windows ICS에서 일반적임)로 사용하며, Google DNS를 구성합니다.

<br/><br/>

### 5.2.4 네트워크 서비스 다시 시작
systemd-networkd 서비스를 다시 시작하여 새 네트워크 구성을 적용합니다:

```
sudo systemctl restart systemd-networkd
```

<br/><br/>

### 5.2.5 네트워크 연결 확인
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ethernet5.png"></p>
<p align="center"><strong>그림 5.5 호스트 PC와 네트워크 공유</strong></p><br/>

Google의 공개 DNS 서버에 핑을 보내 인터넷 연결을 테스트합니다:

```
$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=113 time=30.208 ms
64 bytes from 8.8.8.8: seq=1 ttl=113 time=38.143 ms
64 bytes from 8.8.8.8: seq=2 ttl=113 time=30.969 ms
64 bytes from 8.8.8.8: seq=3 ttl=113 time=33.586 ms
```

<br/><br/><br/><br/>

# 6. 40-pin GPIO 헤더
---
AI-G는 40-pin GPIO 헤더를 갖추고 있어 다양한 하드웨어 프로젝트를 위한 유연한 I/O 기능을 제공합니다.
이 헤더는 범용 입출력(GPIO) 작업과 호환되며 센서, LED, 버튼 및 기타 주변 장치를 연결하는 데 사용할 수 있습니다.

각 핀은 구성에 따라 디지털 I/O, I2C, SPI 또는 UART 기능을 지원합니다.

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.1%2040%20Pin%20GPIO%20Header%20Pinmap%20of%20AI-G.png" width="600"></p>
<p align="center"><strong>그림 6.1 AI-G의 40-pin GPIO 헤더 핀맵  </strong></p><br/>

**참고**: 외부 하드웨어를 연결하기 전에 자세한 핀 기능 및 전압 레벨에 대해서는 공식 핀아웃 다이어그램을 참조하십시오.
<br/><br/><br/><br/>

## 6.1 GPIO 디지털 입력/출력
---
AI-G 보드는 40-pin 헤더를 통해 디지털 입력 및 출력(GPIO)을 지원하여 사용자가 버튼, LED 및 센서와 같은 외부 장치와 상호 작용할 수 있도록 합니다. 
<br/><br/><br/>

### 6.1.1 LED
---
가장 간단하고 일반적인 GPIO 출력 예 중 하나는 LED를 제어하는 것입니다.  
디지털 출력을 시연하기 위해 LED를 40-pin 헤더의 GPIO 핀 중 하나에 연결할 수 있습니다. 이 예에서 LED의 캐소드(짧은 다리)는 AI-G 보드의 GND 핀에 연결되고 애노드(긴 다리)는 GPIO72에 직접 연결됩니다.

#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 브레드보드 (x1)
- LED (x1)
- Male to female 점퍼 와이어 (x2)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)

#### 단계 2. 예제 회로
- LED
    - (+) 핀은 AI-G 보드의 26번 핀에 연결됩니다.
    - (-) 핀은 AI-G 보드의 GND 역할을 하는 14번 핀에 연결됩니다.  

<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.1.1%20AI-G%20GPIO%20LED%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>그림 6.2 AI-G GPIO LED 회로도  </strong></p><br/>

##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.

<div style="text-align: center;">
  <p><strong>표 6.1 AI-G LED 핀 매핑</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">LED (+) 핀</td>
      <td>26</td>
      <td>72</td>
    </tr>
  </table>
</div>
<br/>

#### 단계 3. 실행 방법
AI-G 보드의 GPIO72에 연결된 LED를 작동하려면 다음 코드를 실행하십시오:

```bash
#!/bin/bash

GPIO=72
INTERVAL=1

# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi

echo "out" > /sys/class/gpio/gpio$GPIO/direction

trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT

echo "Toggling GPIO$GPIO every $INTERVAL second(s). Press Ctrl+C to stop."

while true; do
    echo 1 > /sys/class/gpio/gpio$GPIO/value
    sleep $INTERVAL
    echo 0 > /sys/class/gpio/gpio$GPIO/value
    sleep $INTERVAL
done
```

#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_GPIO_LED_TEST
```

이 스크립트는 GPIO72를 디지털 출력으로 구성하고 1초마다 상태를 지속적으로 토글합니다. 실행하면 GPIO72에 연결된 LED가 1초 동안 켜졌다가 1초 동안 꺼지는 것을 무한 반복하며 깜박입니다.

스크립트를 중지하려면 **[Ctrl+C]**를 누르십시오.  
스크립트가 종료되면 GPIO72는 자동으로 unexport되고 정리됩니다.  
실행하기 전에 스크립트에 실행 권한을 부여하십시오:
```bash
$ chmod +x AI_GPIO_LED_TEST
```

**참고**: 이 설정에는 전류 제한 저항이 포함되어 있지 않습니다. 단기 테스트에는 작동할 수 있지만 GPIO 핀의 잠재적인 손상을 방지하기 위해 LED와 직렬로 저항을 사용하는 것이 좋습니다.

<br/><br/><br/><br/>


### 6.1.2 버튼
---
이 예제에서 버튼의 한쪽은 AI-G 보드의 3.3V 전원 핀에 연결되고 다른 쪽은 GPIO79에 연결됩니다. 버튼을 누르면 GPIO79는 1의 high 신호를 읽습니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 브레드보드 (x1)
- 버튼 (x1)
- Male to female 점퍼 와이어 (x2)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- 버튼 스위치
    - 버튼 스위치의 한쪽 다리는 AI-G 보드의 22번 핀에 연결됩니다.
    - 버튼 위의 반대쪽 다리는 3.3V 핀에 연결됩니다.  
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.1.2%20AI-G%20GPIO%20Button%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>그림 6.3 AI-G GPIO 버튼 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>표 6.2 AI-G 버튼 핀 매핑</strong></p>
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">버튼의 한쪽 다리 핀</td>
      <td>22</td>
      <td>79</td>
    </tr>
  </table>
</div>
<br/>
 
#### 단계 3. 실행 방법
AI-G 보드의 GPIO79에 연결된 버튼 입력을 모니터링하려면 다음 코드를 실행하십시오:
 
```bash
#!/bin/bash
 
GPIO=79
 
# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi
 
echo "in" > /sys/class/gpio/gpio$GPIO/direction
 
trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT
 
echo "Monitoring GPIO$GPIO for button press..."
echo "Press Ctrl+C to stop."
 
PREV_VALUE=0
 
while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Button pressed (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```
 
#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_GPIO_BUTTON_TEST
```
 
이 스크립트는 GPIO79를 디지털 입력으로 구성하고 값을 실시간으로 지속적으로 모니터링합니다.  
실행 시 GPIO79에 연결된 버튼을 누르면 버튼이 눌렸음을 나타내는 메시지가 출력됩니다.
 
스크립트를 중지하려면 **[Ctrl+C]**를 누르십시오.  
스크립트가 종료되면 GPIO79는 자동으로 unexport되고 정리됩니다.
실행하기 전에 스크립트에 실행 권한을 부여하십시오:
```bash
$ chmod +x AI_GPIO_BUTTON_TEST
```
 
**참고:** 여기서는 GPIO72와 GPIO79가 예시로 사용되었습니다. 40-pin 헤더 핀맵을 기반으로 AI-G에서 사용 가능한 모든 GPIO 핀을 사용할 수 있습니다. 공식 핀아웃 다이어그램을 참조하여 하드웨어 구성에 맞는 GPIO 번호를 선택하십시오.
 
<br/><br/><br/><br/>
 
 
### 6.1.3 터치 센서
---
터치 센서는 물리적 접촉을 감지하고 터치될 때 high 신호를 출력하는 디지털 입력 장치입니다.
이 예제에서는 터치 센서가 AI-G 보드에 연결되고 GPIO88을 통해 출력이 모니터링됩니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 터치 센서 (x1)
- Female to Female 점퍼 와이어 (x3)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- 터치 센서
    - 터치 센서의 VCC 핀은 AI-G 보드의 3.3V 핀에 연결됩니다.
    - 터치 센서의 GND 핀은 AI-G 보드의 GND에 연결됩니다.
    - 터치 센서의 SIG 핀은 AI-G 보드의 8번 핀(GPIO88)에 연결됩니다.
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/touch.png" width="600"></p>
<p align="center"><strong>그림 6.4 AI-G GPIO 터치 센서 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>표 6.3 AI-G 터치 센서 핀 매핑</strong></p>
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>1</td>
      <td>3.3V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>14</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">SIG</td>
      <td>8</td>
      <td>88</td>
    </tr>
  </table>
</div>
<br/>
 
#### 단계 3. 실행 방법
AI-G 보드의 GPIO88에 연결된 터치 센서 입력을 모니터링하려면 다음 코드를 실행하십시오:
 
```bash
#!/bin/bash
 
GPIO=88
 
# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi
 
echo "in" > /sys/class/gpio/gpio$GPIO/direction
 
trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT
 
echo "Monitoring GPIO$GPIO for touch input..."
echo "Press Ctrl+C to stop."
 
PREV_VALUE=0
 
while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Touch detected (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```
 
#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_TOUCH_TEST
```
 
실행 시 이 스크립트는 GPIO88에서 터치 입력을 감지합니다.
터치 표면에서 접촉이 감지되면 센서가 high 신호를 보내고 콘솔에 "Touch detected (value: 1)" 메시지가 출력됩니다.
 
스크립트를 중지하려면 **[Ctrl+C]**를 누르십시오. 그러면 스크립트가 자동으로 GPIO88을 unexport합니다.
 
스크립트를 실행하기 전에 실행 권한이 있는지 확인하십시오:
```bash
$ chmod +x AI_TOUCH_TEST
```
 
**참고**: 여기서는 GPIO88이 예시로 사용되었습니다. 40-pin 헤더 핀맵을 기반으로 AI-G에서 사용 가능한 모든 GPIO 핀을 사용할 수 있습니다. 충돌을 피하기 위해 AI-G의 공식 40-pin 핀아웃 다이어그램을 참조하십시오.
 
<br/><br/><br/><br/>
 
 
### 6.1.4 진동 감지 센서
---
진동 감지 센서는 물리적 진동이나 충격을 감지하고 진동이 감지되면 high 신호를 출력합니다.
이 예제에서는 센서가 AI-G 보드에 연결되고 디지털 GPIO 89를 통해 진동 입력이 감지됩니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 진동 감지 센서 (x1)
- Female to Female 점퍼 와이어 (x3)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- 진동 감지 센서
    - 진동 감지 센서의 VCC 핀은 AI-G 보드의 5V 핀에 연결됩니다.
    - 진동 감지 센서의 GND 핀은 AI-G 보드의 GND에 연결됩니다.
    - 진동 감지 센서의 디지털 출력(DO) 핀은 AI-G 보드의 10번 핀(GPIO89)에 연결됩니다.
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/vibe.png" width="600"></p>
<p align="center"><strong>그림 6.5 AI-G GPIO 진동 감지 센서 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>표 6.4 AI-G 진동 감지 센서 핀 매핑</strong></p>
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>2</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>20</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">DO</td>
      <td>10</td>
      <td>89</td>
    </tr>
  </table>
</div>
<br/>
 
#### 단계 3. 실행 방법
AI-G 보드의 GPIO89에 연결된 진동 감지 센서 입력을 모니터링하려면 다음 코드를 실행하십시오:
 
```bash
#!/bin/bash
 
GPIO=89
 
# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi
 
echo "in" > /sys/class/gpio/gpio$GPIO/direction
 
trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT
 
echo "Monitoring GPIO$GPIO for vibration..."
echo "Press Ctrl+C to stop."
 
PREV_VALUE=1
 
while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Vibration detected (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```
 
#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_VIBRATION_TEST
```
 
실행 시 이 스크립트는 GPIO89에서 진동 입력을 감지합니다.
센서가 진동이나 충격을 감지한 후 high 신호를 보내고 콘솔에 "Vibration detected (value: 1)" 메시지가 출력됩니다.
 
스크립트를 중지하려면 **[Ctrl+C]**를 누르십시오. 그러면 스크립트가 자동으로 GPIO89를 unexport합니다.
 
스크립트를 실행하기 전에 실행 권한이 있는지 확인하십시오:
```bash
$ chmod +x AI_VIBRATION_TEST
```
 
**참고**: 여기서는 GPIO89가 예시로 사용되었습니다. 40-pin 헤더 핀맵을 기반으로 AI-G에서 사용 가능한 모든 GPIO 핀을 사용할 수 있습니다. 충돌을 피하기 위해 AI-G의 공식 40-pin 핀아웃 다이어그램을 참조하십시오.
 
<br/><br/><br/><br/>
 
 
### 6.1.5 적외선 센서 (SZH-SSBH-002)
---
적외선 센서는 적외선을 방출하고 반사된 빛을 수신하여 주변 장애물을 감지하며, 물체가 감지되면 high 신호를 출력합니다.
이 예제에서는 SZH-SSBH-002 적외선 센서가 AI-G 보드에 연결되고 디지털 GPIO 88을 통해 장애물 감지가 모니터링됩니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 적외선 센서 (SZH-SSBH-002) (x1)
- Female to Female 점퍼 와이어 (x3)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- 적외선 센서
    - 적외선 센서의 VCC 핀은 AI-G 보드의 3.3V 핀에 연결됩니다.
    - 적외선 센서의 GND 핀은 AI-G 보드의 GND에 연결됩니다.
    - 적외선 센서의 OUT 핀은 AI-G 보드의 8번 핀(GPIO88)에 연결됩니다.
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/ir.png" width="600"></p>
<p align="center"><strong>그림 6.6 AI-G GPIO 적외선 센서 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>표 6.5 AI-G 적외선 센서 핀 매핑</strong></p>
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>1</td>
      <td>3.3V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>14</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">OUT</td>
      <td>8</td>
      <td>88</td>
    </tr>
  </table>
</div>
<br/>
 
#### 단계 3. 실행 방법
AI-G 보드의 GPIO88에 연결된 적외선 센서 입력을 모니터링하려면 다음 코드를 실행하십시오:
 
```bash
#!/bin/bash
 
GPIO=88
 
# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi
 
echo "in" > /sys/class/gpio/gpio$GPIO/direction
 
trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT
 
echo "Monitoring GPIO$GPIO for obstacle detection..."
echo "Press Ctrl+C to stop."
 
PREV_VALUE=1
 
while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Obstacle detected (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```
 
#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_GPIO_IR_TEST
```
 
실행 시 이 스크립트는 GPIO88에서 장애물 입력을 감지합니다.
센서가 주변 물체를 감지한 후 high 신호를 보내고 콘솔에 "Obstacle detected (value: 1)" 메시지가 출력됩니다.
 
스크립트를 중지하려면 **[Ctrl+C]**를 누르십시오. 그러면 스크립트가 자동으로 GPIO88을 unexport합니다.
 
스크립트를 실행하기 전에 실행 권한이 있는지 확인하십시오:
```bash
$ chmod +x AI_GPIO_IR_TEST
```
 
**참고**: 여기서는 GPIO88이 예시로 사용되었습니다. 40-pin 헤더 핀맵을 기반으로 AI-G에서 사용 가능한 모든 GPIO 핀을 사용할 수 있습니다. 충돌을 피하기 위해 AI-G의 공식 40-pin 핀아웃 다이어그램을 참조하십시오.
 
<br/><br/><br/><br/>
 
 
### 6.1.6 대기 오염 감지 센서 (디지털 출력)
---
대기 오염 감지 센서(예: MQ 시리즈)는 LPG, 메탄, CO 또는 연기와 같은 가연성 또는 독성 가스의 존재를 감지합니다.
가스 농도가 특정 임계값을 초과하면 센서는 디지털 출력(DO) 핀을 통해 high 신호를 출력합니다.
이 예제에서는 센서가 AI-G 보드에 연결되고 GPIO88을 통해 가스 존재가 감지됩니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 대기 오염 감지 센서 모듈 (x1)
- Female to Female 점퍼 와이어 (x3)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- 대기 오염 감지 센서
    - 대기 오염 감지 센서의 VCC 핀은 AI-G 보드의 5V 핀에 연결됩니다.
    - 대기 오염 감지 센서의 GND 핀은 AI-G 보드의 GND에 연결됩니다.
    - 대기 오염 감지 센서의 디지털 출력(DO) 핀은 AI-G 보드의 8번 핀(GPIO88)에 연결됩니다.
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/air.png" width="600"></p>
<p align="center"><strong>그림 6.7 AI-G GPIO 대기 오염 감지 센서 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
   <p><strong>표 6.6 AI-G 대기 오염 감지 센서 핀 매핑</strong></p>
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>1</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>14</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">SIG</td>
      <td>8</td>
      <td>88</td>
    </tr>
  </table>
</div>
<br/>
 
#### 단계 3. 실행 방법
AI-G 보드의 GPIO88에 연결된 대기 오염 감지 센서 입력을 모니터링하려면 다음 코드를 실행하십시오:
 
```bash
#!/bin/bash
 
GPIO=88
 
# GPIO export
if [ ! -e /sys/class/gpio/gpio$GPIO ]; then
    echo "$GPIO" > /sys/class/gpio/export
    sleep 0.1
fi
 
echo "in" > /sys/class/gpio/gpio$GPIO/direction
 
trap "echo $GPIO > /sys/class/gpio/unexport; echo -e '\nGPIO$GPIO unexported. Exit.'; exit" SIGINT
 
echo "Monitoring GPIO$GPIO for gas detection..."
echo "Press Ctrl+C to stop."
 
PREV_VALUE=1
 
while true; do
    VALUE=$(cat /sys/class/gpio/gpio$GPIO/value)
    if [ "$VALUE" = "1" ] && [ "$PREV_VALUE" = "0" ]; then
        echo "Gas detected! (value: 1)"
    fi
    PREV_VALUE=$VALUE
    sleep 0.1
done
```
 
#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_GPIO_GAS_TEST
```
 
실행 시 이 스크립트는 GPIO88에서 가스 감지를 모니터링합니다.
가스 농도가 임계값을 초과하면 센서가 high 신호를 보내고 콘솔에 "Gas detected! (value: 1)" 메시지가 출력됩니다.
 
스크립트를 중지하려면 **[Ctrl+C]**를 누르십시오. 그러면 스크립트가 자동으로 GPIO88을 unexport합니다.
 
스크립트를 실행하기 전에 실행 권한이 있는지 확인하십시오:
```bash
$ chmod +x AI_GPIO_GAS_TEST
```
 
**참고**: 여기서는 GPIO88이 예시로 사용되었습니다. 40-pin 헤더 핀맵을 기반으로 AI-G에서 사용 가능한 모든 GPIO 핀을 사용할 수 있습니다. 충돌을 피하기 위해 AI-G의 공식 40-pin 핀아웃 다이어그램을 참조하십시오.
 
<br/><br/><br/><br/>


## 6.2 I2C
---
AI-G는 40-pin GPIO 헤더를 통해 I2C 통신을 제공하여 센서, 디스플레이 및 확장 모듈과 같은 다양한 주변 장치와 인터페이스할 수 있습니다. I2C(Inter-Integrated Circuit)는 데이터 라인(SDA)과 클럭 라인(SCL)으로 구성된 2선 통신 프로토콜로, 여러 장치가 공유 버스를 통해 통신할 수 있습니다.
 
I2C 통신은 마스터-슬레이브 아키텍처를 따르며, 하나의 마스터 장치가 통신을 제어하고 최대 127개의 슬레이브 장치를 동일한 버스에 연결할 수 있습니다. SDA 라인은 데이터 송수신 모두에 사용되며, SCL 라인은 데이터 전송 타이밍을 동기화합니다. 이 동기식 통신 모델을 통해 장치는 조정된 클럭 구동 방식으로 정보를 교환할 수 있습니다.
<br/><br/><br/>
 
### 6.2.1 1602A LCD 디스플레이
---
1602A LCD는 임베디드 시스템에서 일반적으로 사용되는 문자 디스플레이 모듈입니다. AI-G에서 LCD의 SDA 및 SCL 라인은 I2C용으로 구성된 GPIO 핀에 연결할 수 있습니다. 연결되면 Linux I2C 도구 또는 사용자 지정 소프트웨어를 사용하여 LCD를 제어할 수 있습니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 1602A LCD 디스플레이 (x1)
- Female to female 점퍼 와이어 (x4)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- LCD1602A
    - LCD1602A의 VCC 핀은 AI-G 보드의 5V 핀에 연결됩니다.
    - LCD1602A의 GND 핀은 AI-G 보드의 GND에 연결됩니다.
    - LCD1602A의 SDA 핀은 AI-G 보드의 3번 핀에 연결됩니다.
    - LCD1602A의 SCL 핀은 AI-G 보드의 5번 핀에 연결됩니다.  
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.2.1%20AI-G%20I2C%20LCD Display%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>그림 6.8 AI-G I2C LCD 디스플레이 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <p><strong>표 6.7 AI-G LCD 디스플레이 핀 매핑</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>6</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>4</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">SDA</td>
      <td>3</td>
      <td>103</td>
    </tr>
    <tr>
      <td colspan="3">SCL</td>
      <td>5</td>
      <td>102</td>
    </tr>
  </table>
</div>
<br/>
 
#### 단계 3. 실행 방법
AI-G 보드에서 I2C 장치에 액세스하려면 i2c-dev 인터페이스를 사용하여 C 프로그램을 작성하고 대상 아키텍처에 대해 크로스 컴파일해야 합니다.  
다음은 간단한 예제(I2C_TEST.c)입니다:
 
```
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <unistd.h>
 
#define I2C_DEV "/dev/i2c-1"
#define I2C_ADDR 0x27
 
// RS: 0 = command, 1 = data
void lcd_send_byte(int fd, unsigned char data, unsigned char mode) {
    unsigned char high = mode | (data & 0xF0) | 0x08; // backlight on
    unsigned char low  = mode | ((data << 4) & 0xF0) | 0x08;
    unsigned char buf[4] = { high | 0x04, high, low | 0x04, low }; // toggle EN bit
 
    for (int i = 0; i < 4; i++) {
        if (write(fd, &buf[i], 1) != 1) {
            perror("I2C write error");
        }
        usleep(1000); // 1ms delay
    }
}
 
void lcd_command(int fd, unsigned char cmd) {
    lcd_send_byte(fd, cmd, 0x00);
}
 
void lcd_data(int fd, unsigned char data) {
    lcd_send_byte(fd, data, 0x01);
}
 
void lcd_init(int fd) {
    usleep(50000); // wait for LCD power on
    lcd_command(fd, 0x33); // init
    lcd_command(fd, 0x32); // 4-bit mode
    lcd_command(fd, 0x28); // 2 line, 5x8 font
    lcd_command(fd, 0x0C); // display on, cursor off
    lcd_command(fd, 0x06); // entry mode
    lcd_command(fd, 0x01); // clear display
    usleep(2000);
}
 
void lcd_print(int fd, const char* str) {
    while (*str) {
        lcd_data(fd, *str++);
    }
}
 
int main() {
    int fd = open(I2C_DEV, O_RDWR);
    if (fd < 0) {
        perror("Failed to open I2C device");
        return 1;
    }
 
    if (ioctl(fd, I2C_SLAVE, I2C_ADDR) < 0) {
        perror("Failed to set I2C address");
        close(fd);
        return 1;
    }
 
    lcd_init(fd);
    lcd_print(fd, "test pass!");
 
    close(fd);
    return 0;
}
```
 
##### 단계 3.1 툴체인 설치 (gcc-arm-9.2)
ARM 64비트(AArch64) 아키텍처용 바이너리를 빌드하려면, 특히 임베디드 Linux 환경에서 크로스 컴파일 툴체인이 필요합니다.
이 단계에서는 AArch64용 GCC ARM 9.2 툴체인을 설치합니다.
 
```
$ wget https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz
 
$ tar -xvf gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz
 
$ echo "export PATH=~/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin:\$PATH" >> ~/.bashrc
$ source ~/.bashrc
 
$ aarch64-none-linux-gnu-gcc --version
aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10)) 9.2.1 20191025
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```
 
##### 단계 3.2 AArch64용 I2C_TEST.c 소스 파일 크로스 컴파일
AI-G용 크로스 컴파일 툴체인을 준비한 다음, 다음 명령을 사용하여 프로그램을 컴파일하십시오:
 
```
$ aarch64-none-linux-gnu-gcc -o I2C_TEST I2C_TEST.c
$ ls
I2C_TEST.c I2C_TEST
```
 
##### 단계 3.3 프로그램을 AI-G로 전송 및 실행
호스트 시스템에서 바이너리를 크로스 컴파일한 후, 다음 명령을 사용하여 바이너리를 AI-G로 전송하십시오:
 
```
$ scp I2C_TEST root@192.168.0.100:/home/root/
```
 
AI-G에서 다음 명령을 사용하여 프로그램을 실행하십시오:
```
$ chmod +x I2C_TEST
$ ./I2C_TEST
```
 
#### 단계 4. 실행 결과
이 프로그램은 1602A I2C LCD 디스플레이를 초기화하고 AI-G 보드의 I2C 인터페이스를 통해 테스트 메시지를 출력합니다. 실행 시 LCD 화면에 "test pass!"라는 메시지가 나타납니다.  
메시지가 나타나지 않으면 다음을 확인하십시오:
- SDA 및 SCL 핀이 올바르게 연결되었는지 확인하십시오.
- I2C 장치 주소가 LCD 모듈과 일치하는지 확인하십시오.
- 전원(5V, GND)이 제대로 공급되는지 확인하십시오.
<br/><br/><br/><br/>
 
 
## 6.3 SPI
---
AI-G는 40-pin GPIO 헤더를 통해 SPI(Serial Peripheral Interface) 통신을 지원하여 외부 장치와 보드 간의 데이터 교환을 가능하게 합니다.  
 
SPI는 전이중 통신을 가능하게 하는 동기식 직렬 통신 프로토콜로, 데이터를 동시에 송수신할 수 있습니다. MOSI(Master Out Slave In), MISO(Master In Slave Out), SCLK(Serial Clock), SS(Slave Select)의 4가지 주요 라인을 사용합니다.
 
여러 장치에 공유 라인을 사용하는 I2C와 달리 SPI는 각 슬레이브 장치에 대해 전용 SS 라인이 필요합니다. 이러한 일대다 구조는 SPI를 빠르고 간단하게 구현할 수 있게 하지만, 여러 장치가 관련된 경우 더 많은 물리적 배선이 필요할 수 있습니다.
<br/><br/><br/>
 
### 6.3.1 도트 매트릭스
---
8x8 도트 매트릭스 디스플레이는 임베디드 시스템에서 간단한 텍스트나 패턴 출력에 일반적으로 사용됩니다. AI-G에서 도트 매트릭스 모듈은 MAX7219와 같은 드라이버 칩을 사용하여 SPI를 통해 제어할 수 있습니다.
 
MAX7219는 행 및 열 스캔을 내부적으로 처리하므로 마이크로컨트롤러는 MOSI(DIN), SCLK, CS(LOAD)와 같은 몇 가지 SPI 신호만 사용하여 전체 디스플레이를 제어할 수 있습니다. 연결되면 사용자 정의 스크립트 또는 라이브러리를 통해 SPI 통신을 사용하여 디스플레이를 제어할 수 있습니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- 8x8 도트 매트릭스
- Female to female 점퍼 와이어 (x5)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
- 8x8 도트 매트릭스
    - 8x8 도트 매트릭스의 VCC 핀은 AI-G 보드의 5V 핀에 연결됩니다.
    - 8x8 도트 매트릭스의 GND 핀은 AI-G 보드의 GND에 연결됩니다.
    - 8x8 도트 매트릭스의 DIN 핀은 AI-G 보드의 19번 핀에 연결됩니다.
    - 8x8 도트 매트릭스의 CS 핀은 AI-G 보드의 24번 핀에 연결됩니다.
    - 8x8 도트 매트릭스의 CLK 핀은 AI-G 보드의 23번 핀에 연결됩니다.
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.3.1%20AI-G%20SPI%20Dot Matrix%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>그림 6.9 AI-G SPI 도트 매트릭스 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <p><strong>표 6.8 AI-G 도트 매트릭스 핀 매핑</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="3">핀 이름</th>
      <th>AI-G</th>
      <th>GPIO</th>
    </tr>
    <tr>
      <td colspan="3">VCC</td>
      <td>2</td>
      <td>5V</td>
    </tr>
    <tr>
      <td colspan="3">GND</td>
      <td>6</td>
      <td>GND</td>
    </tr>
    <tr>
      <td colspan="3">DIN</td>
      <td>19</td>
      <td>94</td>
    </tr>
    <tr>
      <td colspan="3">CS</td>
      <td>24</td>
      <td>93</td>
    </tr>
    <tr>
      <td colspan="3">CLK</td>
      <td>23</td>
      <td>92</td>
    </tr>
  </table>
</div><br/>
 
#### 단계 3. 실행 방법
AI-G에서 SPI 장치와 통신하려면 spidev 인터페이스를 사용하여 C 프로그램을 작성하고 대상 아키텍처에 대해 크로스 컴파일해야 합니다.  
다음은 MAX7219 LED 매트릭스 디스플레이에 데이터를 보내는 간단한 예제(SPI_TEST.c)입니다:
 
```
#include <stdio.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/spi/spidev.h>
#include <sys/ioctl.h>
#include <string.h>
 
#define SPI_DEV "/dev/spidev3.0"
 
int spi_fd = -1;
 
void spi_send(uint8_t address, uint8_t data) {
    uint8_t tx[2] = { address, data };
    struct spi_ioc_transfer tr = {
        .tx_buf = (uintptr_t)tx,
        .rx_buf = 0,
        .len = 2,
        .delay_usecs = 0,
        .speed_hz = 1000000,
        .bits_per_word = 8,
    };
 
    if (ioctl(spi_fd, SPI_IOC_MESSAGE(1), &tr) < 1) {
        perror("SPI send failed");
    }
}
 
void max7219_init() {
    spi_send(0x09, 0x00); // Decode mode off
    spi_send(0x0A, 0x08); // Brightness (0x00 ~ 0x0F)
    spi_send(0x0B, 0x07); // Scan limit: display all 8 digits
    spi_send(0x0C, 0x01); // Shutdown register: normal operation
    spi_send(0x0F, 0x00); // Display test: off
}
 
void max7219_clear() {
    for (int i = 1; i <= 8; i++) {
        spi_send(i, 0x00);
    }
}
 
 
const uint8_t letter_P[8] = {
    0b00000000,  
    0b01111110, 
    0b01000010,  
    0b01000010,  
    0b01111110,  
    0b01000000,  
    0b01000000,  
    0b01000000   
};
 
 
void draw_letter_P() {
    for (int row = 0; row < 8; row++) {
        spi_send(row + 1, letter_P[row]);
    }
}
 
int main() {
    spi_fd = open(SPI_DEV, O_RDWR);
    if (spi_fd < 0) {
        perror("Failed to open SPI device");
        return 1;
    }
 
    max7219_init();
    max7219_clear();
    draw_letter_P();
 
    close(spi_fd);
    return 0;
}
```
 
##### 단계 3.1 툴체인 설치 (gcc-arm-9.2)
ARM 64비트(AArch64) 아키텍처용 바이너리를 빌드하려면, 특히 임베디드 Linux 환경에서 크로스 컴파일 툴체인이 필요합니다.
이 단계에서는 AArch64용 GCC ARM 9.2 툴체인을 설치합니다.
```
$ wget https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz
 
$ tar -xvf gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz
 
$ echo "export PATH=~/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin:\$PATH" >> ~/.bashrc
$ source ~/.bashrc
 
$ aarch64-none-linux-gnu-gcc --version
aarch64-none-linux-gnu-gcc (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10)) 9.2.1 20191025
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```
 
##### 단계 3.2 AArch64용 SPI_TEST.c 소스 파일 크로스 컴파일
AI-G용 크로스 컴파일 툴체인을 준비한 다음, 다음 명령을 사용하여 프로그램을 컴파일하십시오:
 
```
$ aarch64-none-linux-gnu-gcc -o SPI_TEST SPI_TEST.c
$ ls
SPI_TEST.c SPI_TEST
```
 
##### 단계 3.3 프로그램을 AI-G로 전송 및 실행
호스트 시스템에서 바이너리를 크로스 컴파일한 후, 다음 명령을 사용하여 바이너리를 AI-G로 전송하십시오:
 
```
$ scp SPI_TEST root@192.168.0.100:/home/root/
```
 
AI-G에서 다음 명령을 사용하여 프로그램을 실행하십시오:
```
$ chmod +x SPI_TEST
$ ./SPI_TEST
```
 
#### 단계 4. 실행 결과
이 프로그램은 MAX7219 LED 도트 매트릭스 디스플레이를 초기화하고 SPI 인터페이스를 통해 데이터를 전송하여 디스플레이에 문자 **P**를 렌더링합니다. 실행 시 8x8 LED 매트릭스는 미리 정의된 비트 패턴에 따라 문자 **P**를 표시해야 합니다.  
아무것도 나타나지 않거나 패턴이 왜곡된 경우 다음을 확인하십시오:
- SPI 핀(MOSI, SCK, CS)의 배선이 올바른지 확인하십시오.
- MAX7219 모듈에 전원(5V, GND)이 제대로 공급되고 모든 데이터/클럭 라인이 안정적인지 확인하십시오.
<br/><br/><br/><br/>
 
 
## 6.4 UART
---
AI-G는 40-pin GPIO 헤더를 통해 UART(Universal Asynchronous Receiver/Transmitter) 통신을 지원하여 시리얼 콘솔 및 기타 마이크로컨트롤러와 같은 장치와의 시리얼 통신을 가능하게 합니다.  
 
UART는 TX(송신) 및 RX(수신)의 두 라인을 통해 한 번에 한 비트씩 데이터를 전송하는 널리 사용되는 비동기 통신 프로토콜입니다. I2C 또는 SPI와 달리 UART는 클럭 라인을 사용하지 않습니다. 대신 두 장치는 타이밍을 위해 공통 통신 속도를 사용해야 합니다.
<br/><br/><br/>
 
### 6.4.1 UART 루프백 테스트
---
UART 루프백 테스트는 AI-G에서 UART 통신이 올바르게 작동하는지 확인하는 간단한 방법입니다.  
TX와 RX 핀을 함께 연결하면 보드에서 전송된 모든 데이터가 즉시 다시 수신됩니다.  
이 테스트는 Linux 터미널을 사용하여 UART 장치에 데이터를 쓰고 다시 읽음으로써 수행할 수 있습니다.
 
#### 단계 1. 하드웨어 요구 사항
- AI-G 보드 (x1)
- Female to female 점퍼 와이어 (x1)
- DC 5V 전원 어댑터 (x1)
- USB to TTL 시리얼 케이블 (x1)
 
#### 단계 2. 예제 회로
**배선:** TX <-> RX 연결
 
<p align="center"><img src="https://raw.githubusercontent.com/topst-development/Documentation/refs/heads/main/Assets/TOPST%20AI-G/Available%20Applications/3.4.1%20AI-G%20UART%20Circuit%20Schematic.png" width="600"></p>
<p align="center"><strong>그림 6.10 AI-G UART 회로도  </strong></p><br/>
 
##### 단계 2.1 핀 매핑
다음 표는 핀 매핑을 보여줍니다.
 
<div style="text-align: center;">
  <p><strong>표 6.9 AI-G UART 핀 매핑</strong></p>
  <table style="margin: 0 auto; border-collapse: collapse;" border="1">
    <tr>
      <th colspan="2">핀 이름</th>
      <th>AI-G</th>
    </tr>
    <tr>
      <td colspan="2">TX</td>
      <td>10</td>
    </tr>
    <tr>
      <td colspan="2">RX</td>
      <td>8</td>
    </tr>
  </table>
</div><br/>
 
#### 단계 3. 실행 방법
이 스크립트는 UART 포트로 테스트 메시지를 보내고 동일한 메시지가 다시 수신되는지 확인합니다.  
AI-G에서 UART 루프백을 테스트하려면 TX와 RX 핀을 함께 연결한 후 다음 스크립트를 실행하십시오.
 
```bash
#!/bin/bash
# ===================== user setting =====================
UART_DEV="/dev/ttyAMA1"       # uart
BAUD=115200                   # Baudrate
TEST_MSG="Hello from UART"    # msg
TEMP_FILE="/tmp/uart_rx.txt"  # file
# =====================================================
 
if [ ! -e "$UART_DEV" ]; then
    echo "Error: $UART_DEV does not exist"
    exit 1
fi
 
chmod 666 $UART_DEV
 
stty -F $UART_DEV $BAUD cs8 -cstopb -parenb -icanon -echo -ixon -ixoff
echo "UART setup complete: port=$UART_DEV, speed=$BAUD"
 
cat $UART_DEV > $TEMP_FILE &
RX_PID=$!
 
sleep 0.2
echo -n "$TEST_MSG" > $UART_DEV
echo "Transmission complete: \"$TEST_MSG\""
 
sleep 1
kill $RX_PID 2>/dev/null
 
if [ -f "$TEMP_FILE" ]; then
    RECEIVED=$(cat $TEMP_FILE)
    rm $TEMP_FILE
    if [ "$RECEIVED" = "$TEST_MSG" ]; then
        echo "Loopback Success! Received Message: \"$RECEIVED\""
    else
        echo "Received mismatch"
        echo "Sent: \"$TEST_MSG\""
        echo "Received: \"$RECEIVED\""
    fi
else
    echo "Failed to receive: No received file"
fi
```
 
#### 단계 4. 실행 결과
다음 명령으로 코드를 실행하십시오.
```
$ ./AI_UART_LOOPBACK_TEST
```
 
이 스크립트는 지정된 UART 포트를 구성하고 테스트 메시지를 보냅니다. TX와 RX 핀이 올바르게 연결되면 동일한 메시지가 다시 수신되어 터미널에 출력되며, 이는 UART 송수신이 제대로 작동함을 확인합니다.
 
실행하기 전에 스크립트에 실행 권한을 부여하십시오:
```bash
$ chmod +x AI_UART_LOOPBACK_TEST
```
<br/><br/><br/><br/>
